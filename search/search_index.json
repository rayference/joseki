{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>joseki</code> documentation","text":""},{"location":"#table-of-contents","title":"Table of contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#project-layout","title":"Project layout","text":"Project layout <pre><code>    docs/\n        bibliography.bib            # BibTeX file\n        bibliography.md             # Bibliography \n        changelog.md                # Changelog\n        explanation.md              # Understanding-oriented documentation\n        how-to-guides.md            # Task-oriented documentation\n        index.md                    # The documentation homepage.\n        reference.md                # Information-oriented\n        tutorials.md                # Learning-oriented documentation\n    mkdocs.yml                      # The configuration file.\n    pdm.lock                        # PDM lock file\n    pyproject.toml                  # Build system requirements\n    README.md                       # README file\n    src/\n        joseki/                     # Source code\n    tests/\n        profiles/\n            test_afgl_1986.py       # AFGL (1986) profiles tests\n            test_core.py            # Profile core module tests\n            test_factory.py         # Profile factory tests\n            test_mipas_2007.py      # MIPAS (2007) profiles tests\n        test_accessor.py            # Accessor module tests\n        test_core.py                # Core module tests\n        test_main.py                # CLI test module\n        test_units.py               # Units module tests\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#200-unreleased","title":"<code>2.0.0</code> (unreleased)","text":"<p>Documentation</p> <ul> <li>Re-organise content</li> <li>Move from Sphinx to mkdocs</li> </ul> <p>Improvements</p> <ul> <li>Added a profile factory</li> <li>Added profile dataset schema converter and validator</li> <li>Added logging</li> </ul> <p>Internal Changes</p> <ul> <li>Move from Poetry to PDM</li> </ul>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#terminology","title":"Terminology","text":""},{"location":"explanation/#column-number-density","title":"Column number density","text":"<p>If \\(n_{\\mathrm{M}} (z)\\) denotes the number density of molecule M at altitude \\(z\\), then the column number density of molecule M is</p> \\[ N_{\\mathrm{M}} = \\int_{0}^{+\\infty} n_{\\mathrm{M}} (z) \\, \\mathrm{d} z \\] <p>Column number density has dimensions of <code>length^-2</code>.</p>"},{"location":"explanation/#column-mass-density","title":"Column mass density","text":"<p>The column mass density is to mass density what column number density is to number density, i.e.,</p> \\[ P_{\\mathrm{M}} = \\int_{0}^{+\\infty} \\rho_{\\mathrm{M}} (z) \\, \\mathrm{d} z \\] <p>where \\(\\rho_{\\mathrm{M}} (z)\\) is the mass density of molecule M at altitude \\(z\\).</p> <p>Mass density is related with number density through:</p> \\[ \\rho_{\\mathrm{M}} = m_{\\mathrm{M}} \\, n_{\\mathrm{M}} \\] <p>where \\(\\mathrm{M}\\) is the molecular mass.</p> <p>Since molecular mass does not change with altitude, we simply have</p> \\[ P_{\\mathrm{M}} = m_{\\mathrm{M}} \\, N_{\\mathrm{M}} \\] <p>Column mass density has dimensions of <code>mass * length^-2</code>.</p>"},{"location":"explanation/#number-density-at-sea-level","title":"Number density at sea level","text":"<p>Sea level is defined by \\(z=0\\), hence the number density at sea level of molecule M is simply \\(n_{\\mathrm{M}}(0)\\). Number density at sea level has dimensions of <code>length^-3</code>.</p>"},{"location":"explanation/#mass-density-at-sea-level","title":"Mass density at sea level","text":"<p>Similarly, mass density at sea level is \\(\\rho_{\\mathrm{M}}(0) = m_{\\mathrm{M}} \\, n_{\\mathrm{M}}(0)\\). Mass density at sea level has dimensions of <code>mass * length^-3</code>.</p>"},{"location":"explanation/#data-set-format","title":"Data set format","text":"<p>Joseki produces atmospheric profile data sets in the NetCDF format using the xarray library which provides a comprehensive, robust and convenient interface to read, write, manipulate and visualise NetCDF data.</p>"},{"location":"explanation/#metadata-conventions","title":"Metadata conventions","text":"<p>The NetCDF format allows to store metadata alongside data. Joseki's data sets metadata follow the conventions for Climate and Forecast (v1.8).</p>"},{"location":"explanation/#standard-names","title":"Standard names","text":"<p>The Climate and Forecast (CF) conventions define standard names to describe variables. Joseki's data sets comply with CF Standard Name Table Version 77, 19 January 2021, except for the following variables for which a standard name did not exist in the table and was derived:</p> Standard name Long name Units <code>air_number_density</code> <code>air number density</code> <code>m^-3</code> <code>volume_fraction</code> <code>volume fraction</code> <code>dimensionless</code>"},{"location":"explanation/#structure","title":"Structure","text":"<p>The data set includes 4+ data variables:</p> Standard name Long name Symbol Units <code>air_pressure</code> <code>air pressure</code> <code>p</code> <code>Pa</code> <code>air_temperature</code> <code>air temperature</code> <code>t</code> <code>K</code> <code>air_number_density</code> <code>air number density</code> <code>n</code> <code>m^-3</code> <code>volume_fraction</code> <code>volume fraction</code> <code>x_&lt;m&gt;</code> <code>dimensionless</code> <p>where <code>&lt;m&gt;</code> is the chemical formula of the given molecule, and one of the two following coordinates variables</p> Standard name Long name Symbol Units <code>altitude</code> <code>altitude</code> <code>z</code> <code>km</code> <code>layer_center_altitude</code> <code>layer center altitude</code> <code>z</code> <code>km</code> <p>All data variables depend solely on the altitude (either <code>altitude</code> or <code>layer_center_altitude</code>).</p>"},{"location":"how-to-guides/","title":"How-to guides","text":""},{"location":"how-to-guides/#quickstart","title":"Quickstart","text":"<p>Make an atmospheric profile using Joseki's  make method. Use its <code>identifier</code> parameter to specify the atmospheric profile.</p> <p>Example</p> <p>Make the AFGL (1986) US Standard profile with:</p> <pre><code>import joseki\nds = joseki.make(identifier=\"afgl_1986-us_standard\")\n</code></pre> <p>Display the available identifiers with:</p> <pre><code>from joseki.profiles import factory\nlist(factory.registry.keys())\n</code></pre> <p>Use the <code>to_dataset</code> method to save the data set to the disk as a NetCDF file:</p> <pre><code>ds.to_netcdf(\"my_data_set.nc\")\n</code></pre> <p>Open the data set again using  <code>xarray.open_dataset</code>:</p> <pre><code>import xarray as xr\nds = xr.open_dataset(\"my_data_set.nc\")\n</code></pre> <p>The data sets format is described here.</p>"},{"location":"how-to-guides/#cells-representation","title":"Cells representation","text":"<p>To make an atmospheric profile where data variables are given in altitude cells instead of at altitude levels, set the parameter <code>represent_in_cells</code> to <code>True</code>:</p> <pre><code>ds = joseki.make(\nidentifier=\"afgl_1986-us_standard\",\nrepresent_in_cells=True,\n)\n</code></pre> <p>The resulting data set has a coordinate variable <code>z</code> that corresponds to the altitude cells center and a data variable <code>z_bounds</code> that indicate the altitude bounds of each altitude cell, i.e. atmospheric layer.</p>"},{"location":"how-to-guides/#advanced-options","title":"Advanced options","text":"<p>The collection of atmospheric profiles defined by <code>Anderson1986AtmosphericConstituentProfiles</code> includes volume mixing ratio data for 28 molecules, where molecules 8-28 are described as additional. By default, these additional molecules are included in the atmospheric profile. To discard these additional molecules, set the <code>additional_molecules</code> parameter to <code>False</code>:</p> <pre><code>ds = joseki.make(\nidentifier=\"afgl_1986-us_standard\",\nrepresent_in_cells=True,\nadditional_molecules=False,\n)\n</code></pre> <p>The resulting data set now includes only 7 molecules, instead of 28.</p>"},{"location":"how-to-guides/#derived-quantities","title":"Derived quantities","text":"<p>You can compute various derived quantities from a thermophysical properties data set produced by <code>joseki</code>, as illustrated by the examples below.</p> Column number density <pre><code>ds = joseki.make(identifier=\"afgl_1986-us_standard\")\nds.joseki.column_number_density[\"O3\"].to(\"dobson_unit\")\n</code></pre> Column mass density <pre><code>ds.joseki.column_mass_density[\"H2O\"]\n</code></pre> Number density at sea level <pre><code>ds.joseki.number_density_at_sea_level[\"CO2\"]\n</code></pre> Mass density at sea level <pre><code>ds.joseki.mass_density_at_sea_level[\"CH4\"]\n</code></pre> <p>For further details on these methods, refer to the API reference.</p>"},{"location":"how-to-guides/#rescaling","title":"Rescaling","text":"<p>You can modify the amount of a given set of molecules in your thermophysical properties data set by applying a  rescale  transformation.</p> <p>Example</p> <pre><code>ds = joseki.make(identifier=\"afgl_1986-us_standard\")\nrescaled = ds.joseki.rescale(\nfactors={\n\"H2O\": 0.5,\n\"CO2\": 1.5,\n\"CH4\": 1.1,\n}\n)\n</code></pre> <p>In the example above, the amount of water vapor is halfed whereas the amount of carbon dioxide and methane is increased by 150% and 110%, respectively. When a rescale transformation has been applied to a data set, its <code>history</code>  attribute is updated to indicate what scaling factors were applied to what  molecules.</p>"},{"location":"how-to-guides/#plotting","title":"Plotting","text":"<p>Note</p> <p>For plotting, you will need to install the matplotlib library.</p> <p>You can easily make a plot of any of the variables of a dataset, i.e., air pressure (<code>p</code>), air temperature (<code>t</code>), air number density (<code>n</code>) or volume fraction (<code>x_*</code>):</p> Pressure plot <pre><code>import matplotlib.pyplot as plt \nds = joseki.make(\nidentifier=\"afgl_1986-us_standard\",\nadditional_molecules=False\n)\nds.p.plot(\nfigsize=(4, 8),\nls=\"dotted\",\nmarker=\".\",\ny=\"z\",\nxscale=\"log\",\n)\nplt.show()\n</code></pre> <p></p> Temperature plot <pre><code>ds.t.plot(\nfigsize=(4, 8),\nls=\"dotted\",\nmarker=\".\",\ny=\"z\",\nxscale=\"linear\",\n)\nplt.show()\n</code></pre> <p></p> Number density plot <pre><code>ds.n.plot(\nfigsize=(4, 8),\nls=\"dotted\",\nmarker=\".\",\ny=\"z\",\nxscale=\"log\",\n)\nplt.show()\n</code></pre> <p></p> Volume fraction plot <pre><code>plt.figure(figsize=(8, 8)) \nfor m in ds.joseki.molecules:\nds[f\"x_{m}\"].plot(\nls=\"dotted\",\nmarker=\".\",\ny=\"z\",\nxscale=\"log\",\n)\nplt.xlabel(\"volume fraction [dimensionless]\")\nplt.legend(ds.joseki.molecules)\nplt.show()\n</code></pre> <p></p>"},{"location":"reference/","title":"Reference","text":"<p>This reference manual details functions, modules, and objects included in <code>joseki</code>, describing what they are and what they do.</p>"},{"location":"reference/#accessor","title":"Accessor","text":"<p>Accessor module.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor","title":"<code>JosekiAccessor</code>","text":"<p>Joseki accessor.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>@xr.register_dataset_accessor(\"joseki\")\nclass JosekiAccessor:  # pragma: no cover\n\"\"\"Joseki accessor.\"\"\"\ndef __init__(self, xarray_obj):\nself._obj = xarray_obj\n@property\ndef molecules(self) -&gt; t.List[str]:\n\"\"\"Return list of molecules.\"\"\"\nreturn [c[2:] for c in self._obj.data_vars if c.startswith(\"x_\")]\n@property\ndef column_number_density(\nself,\n) -&gt; t.Dict[str, pint.Quantity]:\nr\"\"\"Compute column number density.\n        Returns:\n            A mapping of molecule and column number density.\n        Notes:\n            The column number density is given by:\n            $$\n            N_{\\mathrm{M}} = \\int n_{\\mathrm{M}}(z) \\, \\mathrm{d} z\n            $$\n            with\n            $$\n            n_{\\mathrm{M}}(z) = x_{\\mathrm{M}}(z) \\, n(z)\n            $$\n            where\n            * $z$ is the altitude,\n            * $x_{\\mathrm{M}}(z)$ is the volume mixing ratio of molecule M\n            at altitude $z$,\n            * $n(z)$ is the air number density at altitude $z$,\n            * $n_{\\mathrm{M}}(z)$ is the number density of molecule M at\n            altitude $z$.\n            If the dataset has a `z_bounds` coordinate, the integral is computed\n            using the centered rectangle method, where the `z` coordinate\n            corresponds to the rectangle centers.\n            If the dataset does not have a `z_bounds` coordinate, the \n            integration is performed using the trapezoidal rule.\n        \"\"\"\nds = self._obj\ntry:\nwith xr.set_options(keep_attrs=True):\ndz = to_quantity(ds.z_bounds.diff(dim=\"zbv\", n=1).squeeze())\nn = to_quantity(ds.n)\n_column_number_density = {}\nfor m in self.molecules:\nxm = to_quantity(ds[f\"x_{m}\"])\n_column_number_density[m] = (\n(xm * n * dz).sum().to_base_units()\n)  # integrate using the centered rectangle rule\nreturn _column_number_density\nexcept AttributeError:  # z_bounds attribute does not exist\n_column_number_density = {}\nfor m in self.molecules:\nintegral = (ds[f\"x_{m}\"] * ds.n).integrate(\ncoord=\"z\"\n)  # integrate  using the trapeziodal rule\nunits = \" \".join(\n[ds[var].attrs[\"units\"] for var in [f\"x_{m}\", \"n\", \"z\"]]\n)\n_column_number_density[m] = (\nintegral.values * ureg.Unit(units)\n).to_base_units()\nreturn _column_number_density\n@property\ndef column_mass_density(\nself,\n) -&gt; t.Dict[str, pint.Quantity]:\nr\"\"\"Compute column mass density.\n        Returns:\n            A mapping of molecule and column mass density.\n        Notes:\n            The column mass density is given by:\n            $$\n            \\sigma_{\\mathrm{M}} = N_{\\mathrm{M}} \\, m_{\\mathrm{M}}\n            $$\n            where\n            * $N_{\\mathrm{M}}$ is the column number density of molecule M,\n            * $m_{\\mathrm{M}}$ is the molecular mass of molecule M.\n        \"\"\"\n_column_number_density = self.column_number_density\nreturn {\nm: (molecular_mass(m) * _column_number_density[m]).to(\"kg/m^2\")\nfor m in self.molecules\n}\n@property\ndef number_density_at_sea_level(\nself,\n) -&gt; t.Dict[str, pint.Quantity]:\n\"\"\"Compute number density at sea level.\n        Returns:\n            A mapping of molecule and number density at sea level.\n        \"\"\"\nds = self._obj\nn = to_quantity(ds.n.isel(z=0))\nreturn {m: (to_quantity(ds[f\"x_{m}\"].isel(z=0)) * n) for m in self.molecules}\n@property\ndef mass_density_at_sea_level(\nself,\n) -&gt; t.Dict[str, pint.Quantity]:\n\"\"\"Compute mass density at sea level.\n        Returns:\n            A mapping of molecule and mass density at sea level.\n        \"\"\"\n_number_density_at_sea_level = self.number_density_at_sea_level\nreturn {\nm: (molecular_mass(m) * _number_density_at_sea_level[m]).to(\"kg/m^3\")\nfor m in self.molecules\n}\n@property\ndef volume_fraction_at_sea_level(\nself,\n) -&gt; t.Dict[str, pint.Quantity]:\n\"\"\"Compute volume fraction at sea level.\n        Returns:\n            A mapping of molecule and volume mixing fraction at sea level.\n        \"\"\"\nds = self._obj\nreturn {m: to_quantity(ds[f\"x_{m}\"].isel(z=0)) for m in self.molecules}\n@property\ndef volume_fraction(self) -&gt; xr.DataArray:\n\"\"\"Extract volume fraction and tabulate as a function of (m, z).\n        Returns:\n            Volume fraction.\n        \"\"\"\nds = self._obj\nmolecules = self.molecules\nconcatenated = xr.concat([ds[f\"x_{m}\"] for m in molecules], dim=\"m\")\nconcatenated[\"m\"] = (\"m\", molecules, {\"long_name\": \"molecule\"})\nconcatenated.attrs.update(\n{\n\"standard_name\": \"volume_fraction\",\n\"long_name\": \"volume fraction\",\n\"units\": \"dimensionless\",\n}\n)\nconcatenated.name = \"x\"\nreturn concatenated\ndef scaling_factors(\nself, target: t.MutableMapping[str, pint.Quantity]\n) -&gt; t.MutableMapping[str, float]:\n\"\"\"Compute scaling factor(s) to reach specific target amount(s).\n        Args:\n            target: Mapping of molecule and target amount.\n        Raises:\n            ValueError: If a target amount has dimensions that are not supported.\n        Returns:\n            Mapping of molecule and scaling factors.\n        Notes:\n            For each molecule in the ``target`` mapping, the target amount is\n            interpreted, depending on its dimensions (indicated in square \n            brackets), as:\n            * a column number density [`length^-2`],\n            * a column mass density [`mass * length^-2`],\n            * a number densitx at sea level [`length^-3`],\n            * a mass density at sea level [`mass * length^-3`],\n            * a volume mixing fraction at sea level [`dimensionless`]\n            The scaling factor is then evaluated as the ratio of the target amount\n            with the original amount, for each molecule.\n        See Also:\n            `rescale`\n        \"\"\"\ncompute_initial_amount = {\n\"[length]^-2\": self.column_number_density,\n\"[mass] * [length]^-2\": self.column_mass_density,\n\"[length]^-3\": self.number_density_at_sea_level,\n\"[mass] * [length]^-3\": self.mass_density_at_sea_level,\n\"\": self.volume_fraction_at_sea_level,\n}\nfactors = {}\nfor m, target_amount in target.items():\ninitial_amount = None\nfor dim in compute_initial_amount.keys():\nif target_amount.check(dim):\ninitial_amount = compute_initial_amount[dim][m]\nif initial_amount is None:\nraise ValueError\nfactors[m] = _scaling_factor(\ninitial_amount=initial_amount, target_amount=target_amount\n)\nreturn factors\ndef rescale(\nself,\nfactors: t.MutableMapping[str, float],\ncheck_volume_fraction_sum: bool = False\n) -&gt; xr.Dataset:\n\"\"\"Rescale molecules concentration in atmospheric profile.\n        Args:\n            factors: A mapping of molecule and scaling factor.\n            check_volume_fraction_sum: if True, check that volume fraction sums\n                are never larger than one.\n        Raises:\n            ValueError: if check_volume_fraction_sum is `True` and the \n                dataset is not valid.\n        Returns:\n            Rescaled dataset (new object).\n        \"\"\"\nds = self._obj\n# update volume fraction\nx_new = {}\nfor m in factors:\nwith xr.set_options(keep_attrs=True):\nx_new[f\"x_{m}\"] = ds[f\"x_{m}\"] * factors[m]\nds = ds.assign(x_new)\n# validate rescaled dataset\ntry:\nds.joseki.validate(check_volume_fraction_sum=check_volume_fraction_sum)\nexcept ValueError as e:\nraise ValueError(\"Cannot rescale\") from e\n# update history attribute\nnow = datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\nfor m in factors.keys():\nds.attrs[\"history\"] += (\nf\"\\n{now} - rescaled {m}'s volume mixing ratio using a scaling \"\nf\"factor of {factors[m]:.3f} - joseki, version {__version__}\"\n)\nreturn ds\ndef validate(\nself,\ncheck_volume_fraction_sum: bool = False,\nret_true_if_valid: bool = False,\n) -&gt; bool:\n\"\"\"Validate atmosphere thermophysical profile data set schema.\n        Returns:\n            `True` if the dataset complies with the schema, else `False`.\n        \"\"\"\nreturn schema.validate(\nds=self._obj,\ncheck_volume_fraction_sum=check_volume_fraction_sum,\nret_true_if_valid=ret_true_if_valid,\n)\n@property\ndef is_valid(self):\nreturn self.validate(ret_true_if_valid=True)\n</code></pre>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.column_mass_density","title":"<code>column_mass_density: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute column mass density.</p> <p>Returns:</p> Type Description <code>t.Dict[str, pint.Quantity]</code> <p>A mapping of molecule and column mass density.</p> Notes <p>The column mass density is given by:</p> \\[ \\sigma_{\\mathrm{M}} = N_{\\mathrm{M}} \\, m_{\\mathrm{M}} \\] <p>where</p> <ul> <li>\\(N_{\\mathrm{M}}\\) is the column number density of molecule M,</li> <li>\\(m_{\\mathrm{M}}\\) is the molecular mass of molecule M.</li> </ul>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.column_number_density","title":"<code>column_number_density: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute column number density.</p> <p>Returns:</p> Type Description <code>t.Dict[str, pint.Quantity]</code> <p>A mapping of molecule and column number density.</p> Notes <p>The column number density is given by:</p> \\[ N_{\\mathrm{M}} = \\int n_{\\mathrm{M}}(z) \\, \\mathrm{d} z \\] <p>with</p> \\[ n_{\\mathrm{M}}(z) = x_{\\mathrm{M}}(z) \\, n(z) \\] <p>where</p> <ul> <li>\\(z\\) is the altitude,</li> <li>\\(x_{\\mathrm{M}}(z)\\) is the volume mixing ratio of molecule M at altitude \\(z\\),</li> <li>\\(n(z)\\) is the air number density at altitude \\(z\\),</li> <li>\\(n_{\\mathrm{M}}(z)\\) is the number density of molecule M at altitude \\(z\\).</li> </ul> <p>If the dataset has a <code>z_bounds</code> coordinate, the integral is computed using the centered rectangle method, where the <code>z</code> coordinate corresponds to the rectangle centers.</p> <p>If the dataset does not have a <code>z_bounds</code> coordinate, the  integration is performed using the trapezoidal rule.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.mass_density_at_sea_level","title":"<code>mass_density_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute mass density at sea level.</p> <p>Returns:</p> Type Description <code>t.Dict[str, pint.Quantity]</code> <p>A mapping of molecule and mass density at sea level.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.molecules","title":"<code>molecules: t.List[str]</code>  <code>property</code>","text":"<p>Return list of molecules.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.number_density_at_sea_level","title":"<code>number_density_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute number density at sea level.</p> <p>Returns:</p> Type Description <code>t.Dict[str, pint.Quantity]</code> <p>A mapping of molecule and number density at sea level.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.volume_fraction","title":"<code>volume_fraction: xr.DataArray</code>  <code>property</code>","text":"<p>Extract volume fraction and tabulate as a function of (m, z).</p> <p>Returns:</p> Type Description <code>xr.DataArray</code> <p>Volume fraction.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.volume_fraction_at_sea_level","title":"<code>volume_fraction_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute volume fraction at sea level.</p> <p>Returns:</p> Type Description <code>t.Dict[str, pint.Quantity]</code> <p>A mapping of molecule and volume mixing fraction at sea level.</p>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.rescale","title":"<code>rescale(factors, check_volume_fraction_sum=False)</code>","text":"<p>Rescale molecules concentration in atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>factors</code> <code>t.MutableMapping[str, float]</code> <p>A mapping of molecule and scaling factor.</p> required <code>check_volume_fraction_sum</code> <code>bool</code> <p>if True, check that volume fraction sums are never larger than one.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if check_volume_fraction_sum is <code>True</code> and the  dataset is not valid.</p> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Rescaled dataset (new object).</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def rescale(\nself,\nfactors: t.MutableMapping[str, float],\ncheck_volume_fraction_sum: bool = False\n) -&gt; xr.Dataset:\n\"\"\"Rescale molecules concentration in atmospheric profile.\n    Args:\n        factors: A mapping of molecule and scaling factor.\n        check_volume_fraction_sum: if True, check that volume fraction sums\n            are never larger than one.\n    Raises:\n        ValueError: if check_volume_fraction_sum is `True` and the \n            dataset is not valid.\n    Returns:\n        Rescaled dataset (new object).\n    \"\"\"\nds = self._obj\n# update volume fraction\nx_new = {}\nfor m in factors:\nwith xr.set_options(keep_attrs=True):\nx_new[f\"x_{m}\"] = ds[f\"x_{m}\"] * factors[m]\nds = ds.assign(x_new)\n# validate rescaled dataset\ntry:\nds.joseki.validate(check_volume_fraction_sum=check_volume_fraction_sum)\nexcept ValueError as e:\nraise ValueError(\"Cannot rescale\") from e\n# update history attribute\nnow = datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\nfor m in factors.keys():\nds.attrs[\"history\"] += (\nf\"\\n{now} - rescaled {m}'s volume mixing ratio using a scaling \"\nf\"factor of {factors[m]:.3f} - joseki, version {__version__}\"\n)\nreturn ds\n</code></pre>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.scaling_factors","title":"<code>scaling_factors(target)</code>","text":"<p>Compute scaling factor(s) to reach specific target amount(s).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>t.MutableMapping[str, pint.Quantity]</code> <p>Mapping of molecule and target amount.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a target amount has dimensions that are not supported.</p> <p>Returns:</p> Type Description <code>t.MutableMapping[str, float]</code> <p>Mapping of molecule and scaling factors.</p> Notes <p>For each molecule in the <code>target</code> mapping, the target amount is interpreted, depending on its dimensions (indicated in square  brackets), as:</p> <ul> <li>a column number density [<code>length^-2</code>],</li> <li>a column mass density [<code>mass * length^-2</code>],</li> <li>a number densitx at sea level [<code>length^-3</code>],</li> <li>a mass density at sea level [<code>mass * length^-3</code>],</li> <li>a volume mixing fraction at sea level [<code>dimensionless</code>]</li> </ul> <p>The scaling factor is then evaluated as the ratio of the target amount with the original amount, for each molecule.</p> See Also <p><code>rescale</code></p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def scaling_factors(\nself, target: t.MutableMapping[str, pint.Quantity]\n) -&gt; t.MutableMapping[str, float]:\n\"\"\"Compute scaling factor(s) to reach specific target amount(s).\n    Args:\n        target: Mapping of molecule and target amount.\n    Raises:\n        ValueError: If a target amount has dimensions that are not supported.\n    Returns:\n        Mapping of molecule and scaling factors.\n    Notes:\n        For each molecule in the ``target`` mapping, the target amount is\n        interpreted, depending on its dimensions (indicated in square \n        brackets), as:\n        * a column number density [`length^-2`],\n        * a column mass density [`mass * length^-2`],\n        * a number densitx at sea level [`length^-3`],\n        * a mass density at sea level [`mass * length^-3`],\n        * a volume mixing fraction at sea level [`dimensionless`]\n        The scaling factor is then evaluated as the ratio of the target amount\n        with the original amount, for each molecule.\n    See Also:\n        `rescale`\n    \"\"\"\ncompute_initial_amount = {\n\"[length]^-2\": self.column_number_density,\n\"[mass] * [length]^-2\": self.column_mass_density,\n\"[length]^-3\": self.number_density_at_sea_level,\n\"[mass] * [length]^-3\": self.mass_density_at_sea_level,\n\"\": self.volume_fraction_at_sea_level,\n}\nfactors = {}\nfor m, target_amount in target.items():\ninitial_amount = None\nfor dim in compute_initial_amount.keys():\nif target_amount.check(dim):\ninitial_amount = compute_initial_amount[dim][m]\nif initial_amount is None:\nraise ValueError\nfactors[m] = _scaling_factor(\ninitial_amount=initial_amount, target_amount=target_amount\n)\nreturn factors\n</code></pre>"},{"location":"reference/#src.joseki.accessor.JosekiAccessor.validate","title":"<code>validate(check_volume_fraction_sum=False, ret_true_if_valid=False)</code>","text":"<p>Validate atmosphere thermophysical profile data set schema.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the dataset complies with the schema, else <code>False</code>.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def validate(\nself,\ncheck_volume_fraction_sum: bool = False,\nret_true_if_valid: bool = False,\n) -&gt; bool:\n\"\"\"Validate atmosphere thermophysical profile data set schema.\n    Returns:\n        `True` if the dataset complies with the schema, else `False`.\n    \"\"\"\nreturn schema.validate(\nds=self._obj,\ncheck_volume_fraction_sum=check_volume_fraction_sum,\nret_true_if_valid=ret_true_if_valid,\n)\n</code></pre>"},{"location":"reference/#src.joseki.accessor.molecular_mass","title":"<code>molecular_mass(m)</code>","text":"<p>Return the average molecular mass of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>str</code> <p>Molecule formula.</p> required <p>Returns:</p> Type Description <code>pint.Quantity</code> <p>Average molecular mass.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def molecular_mass(m: str) -&gt; pint.Quantity:\n\"\"\"Return the average molecular mass of a molecule.\n    Args:\n        m: Molecule formula.\n    Returns:\n        Average molecular mass.\n    \"\"\"\nreturn MM[m] * ureg(\"dalton\")\n</code></pre>"},{"location":"reference/#data","title":"Data","text":"<p>Raw data files.</p>"},{"location":"reference/#profiles","title":"Profiles","text":""},{"location":"reference/#factory","title":"Factory","text":"<p>Profile factory module.</p>"},{"location":"reference/#src.joseki.profiles.factory.ProfileFactory","title":"<code>ProfileFactory</code>","text":"<p>Profile factory class.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>@define\nclass ProfileFactory:\n\"\"\"\n    Profile factory class.\n    \"\"\"\n\"\"\"Profile registry.\"\"\"\nregistry: t.Dict[str, Profile] = field(factory=dict)\ndef register(\nself,\nidentifier: str,\n) -&gt; t.Callable:\n\"\"\"\n        Register a profile class.\n        Args:\n            identifier: Profile identifier.\n        Returns:\n            Decorator function.\n        \"\"\"\ndef inner_wrapper(wrapped_class: Profile) -&gt; t.Callable:\nlogger.info(\"Registering profile %s\", identifier)\nif identifier in self.registry:\nlogger.warning(  # pragma: no cover\n\"Profile %s already exists. Will replace it\",\nidentifier,\n)\nself.registry[identifier] = wrapped_class\nreturn wrapped_class\nreturn inner_wrapper\ndef create(self, identifier: str, **kwargs) -&gt; Profile:\n\"\"\"\n        Create a profile instance.\n        Args:\n            identifier: Profile identifier.\n        Returns:\n            Profile instance.\n        \"\"\"\nif identifier not in self.registry:\nlogger.fatal(\"Profile %s does not exist in the registry\", identifier)\nraise ValueError(f\"Profile {identifier} does not exist in the registry\")\nlogger.debug(\"Creating profile %s\", identifier)\nprofile_cls = self.registry[identifier]\nprofile = profile_cls(**kwargs)\nreturn profile\n</code></pre>"},{"location":"reference/#src.joseki.profiles.factory.ProfileFactory.create","title":"<code>create(identifier, **kwargs)</code>","text":"<p>Create a profile instance.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <p>Returns:</p> Type Description <code>Profile</code> <p>Profile instance.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>def create(self, identifier: str, **kwargs) -&gt; Profile:\n\"\"\"\n    Create a profile instance.\n    Args:\n        identifier: Profile identifier.\n    Returns:\n        Profile instance.\n    \"\"\"\nif identifier not in self.registry:\nlogger.fatal(\"Profile %s does not exist in the registry\", identifier)\nraise ValueError(f\"Profile {identifier} does not exist in the registry\")\nlogger.debug(\"Creating profile %s\", identifier)\nprofile_cls = self.registry[identifier]\nprofile = profile_cls(**kwargs)\nreturn profile\n</code></pre>"},{"location":"reference/#src.joseki.profiles.factory.ProfileFactory.register","title":"<code>register(identifier)</code>","text":"<p>Register a profile class.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <p>Returns:</p> Type Description <code>t.Callable</code> <p>Decorator function.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>def register(\nself,\nidentifier: str,\n) -&gt; t.Callable:\n\"\"\"\n    Register a profile class.\n    Args:\n        identifier: Profile identifier.\n    Returns:\n        Decorator function.\n    \"\"\"\ndef inner_wrapper(wrapped_class: Profile) -&gt; t.Callable:\nlogger.info(\"Registering profile %s\", identifier)\nif identifier in self.registry:\nlogger.warning(  # pragma: no cover\n\"Profile %s already exists. Will replace it\",\nidentifier,\n)\nself.registry[identifier] = wrapped_class\nreturn wrapped_class\nreturn inner_wrapper\n</code></pre>"},{"location":"reference/#core","title":"Core","text":"<p>Core module for atmosphere thermophysical profiles.</p> <p>The <code>Profile</code> abstract class defines the interface for atmosphere thermophysical profiles. The <code>interp</code> function is used to interpolate an atmosphere thermophysical profile on new altitude values. The <code>represent_profile_in_cells</code> function is used to compute the cells representation of the atmosphere thermophysical profile.</p>"},{"location":"reference/#src.joseki.profiles.core.Profile","title":"<code>Profile</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract class for atmosphere thermophysical profiles.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>@define\nclass Profile(ABC):\n\"\"\"\n    Abstract class for atmosphere thermophysical profiles.\n    \"\"\"\n@abstractmethod\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n\"\"\"\n        Return the profile as a dataset.\n        Args:\n            z: Altitude grid.\n                If the profile can be evaluated at arbitrary altitudes, this\n                parameter is passed to the evaluating method for that profile.\n                If the profile is defined on a fixed altitude grid, this parameter\n                is used to interpolate the profile on the specified altitude grid.\n            interp_method: Interpolation method for each variable.\n                If ``None``, the default interpolation method is used.\n                Interpolation may be required if the profile is defined on a fixed\n                altitude grid, and the altitude grid is not the same as the one\n                used to define the profile.\n                Interpolation may also not be required, e.g. if the profile is\n                defined by analytical function(s) of the altitude variable.\n            kwargs: Parameters passed to lower-level methods.\n        Returns:\n            Atmospheric profile.\n        \"\"\"\npass  # pragma: no cover\n</code></pre>"},{"location":"reference/#src.joseki.profiles.core.Profile.to_dataset","title":"<code>to_dataset(z=None, interp_method=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Return the profile as a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>t.Optional[pint.Quantity]</code> <p>Altitude grid. If the profile can be evaluated at arbitrary altitudes, this parameter is passed to the evaluating method for that profile. If the profile is defined on a fixed altitude grid, this parameter is used to interpolate the profile on the specified altitude grid.</p> <code>None</code> <code>interp_method</code> <code>t.Optional[t.Mapping[str, str]]</code> <p>Interpolation method for each variable. If <code>None</code>, the default interpolation method is used. Interpolation may be required if the profile is defined on a fixed altitude grid, and the altitude grid is not the same as the one used to define the profile. Interpolation may also not be required, e.g. if the profile is defined by analytical function(s) of the altitude variable.</p> <code>None</code> <code>kwargs</code> <code>t.Any</code> <p>Parameters passed to lower-level methods.</p> <code>{}</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>@abstractmethod\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n\"\"\"\n    Return the profile as a dataset.\n    Args:\n        z: Altitude grid.\n            If the profile can be evaluated at arbitrary altitudes, this\n            parameter is passed to the evaluating method for that profile.\n            If the profile is defined on a fixed altitude grid, this parameter\n            is used to interpolate the profile on the specified altitude grid.\n        interp_method: Interpolation method for each variable.\n            If ``None``, the default interpolation method is used.\n            Interpolation may be required if the profile is defined on a fixed\n            altitude grid, and the altitude grid is not the same as the one\n            used to define the profile.\n            Interpolation may also not be required, e.g. if the profile is\n            defined by analytical function(s) of the altitude variable.\n        kwargs: Parameters passed to lower-level methods.\n    Returns:\n        Atmospheric profile.\n    \"\"\"\npass  # pragma: no cover\n</code></pre>"},{"location":"reference/#src.joseki.profiles.core.interp","title":"<code>interp(ds, z_new, method=DEFAULT_METHOD)</code>","text":"<p>Interpolate atmospheric profile on new altitudes.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>Atmospheric profile to interpolate.</p> required <code>z_new</code> <code>pint.Quantity</code> <p>Altitudes values at which to interpolate the atmospheric profile.</p> required Mapping of variable and interpolation method. <p>If a variable is not in the mapping, the linear interpolation is used. By default, linear interpolation is used for all variables.</p> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Interpolated atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def interp(\nds: xr.Dataset,\nz_new: pint.Quantity,\nmethod: t.Dict[str, str] = DEFAULT_METHOD,\n) -&gt; xr.Dataset:\n\"\"\"Interpolate atmospheric profile on new altitudes.\n    Args:\n        ds: Atmospheric profile to interpolate.\n        z_new: Altitudes values at which to interpolate the atmospheric profile.\n    method: Mapping of variable and interpolation method.\n        If a variable is not in the mapping, the linear interpolation is used.\n        By default, linear interpolation is used for all variables.\n    Returns:\n        Interpolated atmospheric profile.\n    \"\"\"\nz_units = ds.z.attrs[\"units\"]\nz_new_values = z_new.m_as(z_units)\ncoords = {\"z\": z_new.to(z_units)}\n# Interpolate pressure, temperature and density\ndata_vars = {}\nfor var in [\"p\", \"t\", \"n\"]:\nf = interpolate.interp1d(\nx=ds.z.values,\ny=ds[var].values,\nkind=method.get(var, method[\"default\"]),\nbounds_error=True,\n)\ndata_vars[var] = ureg.Quantity(f(z_new_values), ds[var].attrs[\"units\"])\n# Interpolate volume fraction\nfor m in ds.joseki.molecules:\nvar = f\"x_{m}\"\nf = interpolate.interp1d(\nx=ds.z.values,\ny=ds[var].values,\nkind=method.get(var, method[\"default\"]),\nbounds_error=True,\n)\ndata_vars[var] = ureg.Quantity(f(z_new_values), ds[var].attrs[\"units\"])\n# Attributes\nattrs = ds.attrs\nauthor = f\"joseki, version {__version__}\"\nattrs.update(\n{\n\"history\": f\"{utcnow()} - data set interpolation by {author}.\",\n}\n)\n# Convert to data set\nlogger.debug(\"convert interpolated data to data set\")\ninterpolated = schema.convert(\ndata_vars=data_vars,\ncoords=coords,\nattrs=attrs,\n)\nreturn interpolated\n</code></pre>"},{"location":"reference/#src.joseki.profiles.core.represent_profile_in_cells","title":"<code>represent_profile_in_cells(ds, method=DEFAULT_METHOD)</code>","text":"<p>Compute the cells representation of the atmosphere thermophysical profile.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>Initial atmospheric profile.</p> required <code>method</code> <code>t.Dict[str, str]</code> <p>Mapping of variable and interpolation method. If a variable is not in the mapping, the linear interpolation is used. By default, linear interpolation is used for all variables.</p> <code>DEFAULT_METHOD</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Cells representation of the atmosphere thermophysical profile.</p> Notes <p>Atmosphere cells (or layers) are defined by two consecutive altitude  values. The layer's center altitude is defined as the arithmetic  average of these two values. The pressure, temperature, number density  and volume fraction fields are interpolated at these layer' center  altitude values. In the new atmospheric profile, the <code>z</code> coordinate  is updated with layer' center altitude values and a data variable  <code>z_bounds</code> indicating the altitude bounds of each layer, is added. A copy of the data set is returned, the original data set is not  modified.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def represent_profile_in_cells(\nds: xr.Dataset,\nmethod: t.Dict[str, str] = DEFAULT_METHOD,\n) -&gt; xr.Dataset:\n\"\"\"Compute the cells representation of the atmosphere thermophysical profile.\n    Args:\n        ds: Initial atmospheric profile.\n        method: Mapping of variable and interpolation method.\n            If a variable is not in the mapping, the linear interpolation is used.\n            By default, linear interpolation is used for all variables.\n    Returns:\n        Cells representation of the atmosphere thermophysical profile.\n    Notes:\n        Atmosphere cells (or layers) are defined by two consecutive altitude \n        values. The layer's center altitude is defined as the arithmetic \n        average of these two values. The pressure, temperature, number density \n        and volume fraction fields are interpolated at these layer' center \n        altitude values. In the new atmospheric profile, the `z` coordinate \n        is updated with layer' center altitude values and a data variable \n        `z_bounds` indicating the altitude bounds of each layer, is added.\n        A copy of the data set is returned, the original data set is not \n        modified.\n    \"\"\"\n# if the profile is already represented in cells, do nothing\nif ds.z.standard_name == \"layer_center_altitude\":\nreturn ds\nz_nodes = to_quantity(ds.z)\nz_centers = (z_nodes[:-1] + z_nodes[1:]) / 2.0\ninterpolated: xr.Dataset = interp(\nds=ds,\nz_new=z_centers,\nmethod=method,\n)\ninterpolated.z.attrs = dict(\nstandard_name=\"layer_center_altitude\",\nlong_name=\"layer center altitude\",\nunits=\"km\",\n)\nz_bounds = np.stack([z_nodes[:-1], z_nodes[1:]])\ninterpolated = interpolated.assign(\nz_bounds=(\n(\"zbv\", \"z\"),\nz_bounds.m_as(\"km\"),\ndict(\nstandard_name=\"cell_bound_altitude\",\nlong_name=\"cell bound altitude\",\nunits=\"km\",\n),\n)\n)\ninterpolated.attrs.update(\nhistory=interpolated.history + f\"\\n{utcnow()} \"\nf\"- represent profile on cells - joseki, version {__version__}\"\n)\nreturn interpolated\n</code></pre>"},{"location":"reference/#dataset-schema","title":"Dataset schema","text":"<p>Dataset schema for atmosphere thermophysical profiles.</p> <p>The dataset schema defines the variables, coordinates and attributes that are expected in a dataset representing an atmosphere thermophysical profile.</p>"},{"location":"reference/#src.joseki.profiles.schema.Schema","title":"<code>Schema</code>","text":"<p>Dataset schema for atmosphere thermophysical profiles.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>@define(frozen=True)\nclass Schema:\n\"\"\"Dataset schema for atmosphere thermophysical profiles.\"\"\"\ndata_vars = {\n\"p\": ([\"z\"], npt.NDArray[np.float64], \"Pa\", \"air_pressure\"),\n\"t\": ([\"z\"], npt.NDArray[np.float64], \"K\", \"air_temperature\"),\n\"n\": ([\"z\"], npt.NDArray[np.float64], \"m^-3\", \"air_number_density\"),\n}\ncoords = {\n\"z\": (\"z\", npt.NDArray[np.float64], \"km\", \"altitude\"),\n}\nattrs = {\n\"Conventions\": str,\n\"title\": str,\n\"institution\": str,\n\"source\": str,\n\"history\": str,\n\"references\": str,\n\"url\": str,\n\"urldate\": str,\n}\ndef validate(\nself,\nds: xr.Dataset,\ncheck_volume_fraction_sum: bool = False,\nret_true_if_valid: bool = False,\n) -&gt; t.Optional[bool]:\n\"\"\"Validate dataset.\n        Args:\n            ds: Dataset to validate.\n            check_volume_fraction_sum: if True, check that volume fraction sums\n                are never larger than one.\n            ret_true_if_valid: make this method return True if the dataset is\n                valid.\n        Raises:\n            ValueError: If the dataset does not match the schema.\n        Returns:\n            None or bool: If `ret_true_if_valid` is True, returns True if the \n                dataset is valid, otherwise returns None.\n        \"\"\"\nlogger.debug(\"Validating dataset\")\nlogger.debug(\"Checking that all data variables are present\")\nfor var in self.data_vars:\nif var not in ds.data_vars:\nraise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\nlogger.debug(\"Checking that 'x_*' data variable(s) are present\")\nif not any([name.startswith(\"x_\") for name in ds.data_vars]):\nraise ValueError(\"missing data variable starting with x_\")  # pragma: no cover\nlogger.debug(\"Checking that all coordinates are present\")\nfor coord in self.coords:\nif coord not in ds.coords:\nraise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\nlogger.debug(\"Checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in ds.attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"Checking that data variables have the correct dimensions\")\nfor var, (dims, _, _, _) in self.data_vars.items():\nif set(ds[var].dims) != set(dims):\nraise ValueError(  # pragma: no cover\nf\"incorrect dimensions for {var}. Expected {dims}, \"\nf\"got {ds[var].dims}\"\n)\nlogger.debug(\"Checking that coordinates have the correct dimensions\")\nfor coord, (dims, _, _, _) in self.coords.items():\nif set(ds[coord].dims) != set(dims):\nraise ValueError(  # pragma: no cover\nf\"incorrect dimensions for {coord}. Expected {dims}, \"\nf\"got {ds[coord].dims}\"\n)\nlogger.debug(\"Checking that data variables have the correct units\")\nfor var, (_, _, units, _) in self.data_vars.items():\nif ds[var].units != units:\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {var}. Expected {units}, \"\nf\"got {ds[var].units}\"\n)\nlogger.debug(\"Checking that coordinates have the correct units\")\nfor coord, (_, _, units, _) in self.coords.items():\nif ds[coord].units != units:\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {coord}. Expected {units}, \"\nf\"got {ds[coord].units}\"\n)\nlogger.debug(\"Checking that attributes have the correct types\")\nfor attr, typ in self.attrs.items():\nif not isinstance(ds.attrs[attr], typ):\nraise ValueError(  # pragma: no cover\nf\"incorrect type for {attr}. Expected {typ}, \"\nf\"got {type(ds.attrs[attr])}\"\n)\nlogger.debug(\"Checking that data variables have the correct standard names\")\nfor var, (_, _, _, standard_name) in self.data_vars.items():\nif ds[var].attrs[\"standard_name\"] != standard_name:\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {var}. Expected \"\nf\"{standard_name}, got \"\nf\"{ds[var].attrs['standard_name']}\"\n)\nlogger.debug(\"Checking that coordinates have the correct standard names\")\nfor coord, (_, _, _, standard_name) in self.coords.items():\nif ds[coord].attrs[\"standard_name\"] != standard_name:\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {coord}. Expected \"\nf\"{standard_name}, got \"\nf\"{ds[coord].attrs['standard_name']}\"\n)\nlogger.debug(\n\"Checking that all x_* data variables have the correct units and \"\n\"standard names\"\n)\nfor var in ds.data_vars:\nif var.startswith(\"x_\"):\nm = var[2:]\nif ds[var].attrs[\"units\"] != \"dimensionless\":\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {var}. Expected dimensionless, \"\nf\"got {ds[var].attrs['units']}\"\n)\nif ds[var].attrs[\"standard_name\"] != f\"{m}_volume_fraction\":\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {var}. Expected \"\nf\"{m}_volume_fraction, got \"\nf\"{ds[var].attrs['standard_name']}\"\n)\nif check_volume_fraction_sum:\nlogger.debug(\n\"Checking that volume fraction sums are never larger than one\"\n)\nvfs = volume_fraction_sum(ds)\nif np.any(vfs.m &gt; 1):\nraise ValueError(\n\"The rescaling factors lead to a profile where the volume \"\n\"fraction sum is larger than 1.\"\n)\nlogger.info(\"Dataset is valid\")\nif ret_true_if_valid:  # pragma: no cover\nreturn True\ndef convert(\nself,\ndata_vars: t.Mapping[str, pint.Quantity],\ncoords: t.Mapping[str, pint.Quantity],\nattrs: t.Mapping[str, str],\n) -&gt; xr.Dataset:\n\"\"\"Convert input to schema-compliant dataset.\n        Args:\n            data_vars: Mapping of data variable names to quantities.\n            coords: Mapping of coordinate names to quantities.\n            attrs: Mapping of attribute names to values.\n        Returns:\n            Dataset with schema-compliant data variables, coordinates, and\n            attributes.\n        \"\"\"\nlogger.debug(\"converting input to schema-compliant dataset\")\nlogger.debug(\"checking that all data variables are present\")\nfor var in self.data_vars:\nif var not in data_vars:\nraise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\nlogger.debug(\"checking that there is at least one x_ data variable\")\nif not any([name.startswith(\"x_\") for name in data_vars]):\nraise ValueError(\"missing data variable starting with x_\")  # pragma: no cover\nlogger.debug(\"checking that all coordinates are present\")\nfor coord in self.coords:\nif coord not in coords:\nraise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\nlogger.debug(\"checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"converting data variables to xarray data array tuples\")\nfor var, (dims, _, units, standard_name) in self.data_vars.items():\ndata_vars[var] = (\ndims,\ndata_vars[var].m_as(units),\n{\n\"standard_name\": standard_name,\n\"long_name\": standard_name.replace(\"_\", \" \"),\n\"units\": units,\n},\n)\nlogger.debug(\"converting x_ data variables\")\nfor var in data_vars:\nif var.startswith(\"x_\"):\nm = var[2:]\ndata_vars[var] = (\n\"z\",\ndata_vars[var].m_as(\"dimensionless\"),\n{\n\"standard_name\": f\"{m}_volume_fraction\",\n\"long_name\": f\"{m} volume fraction\",\n\"units\": \"dimensionless\",\n},\n)\nlogger.debug(\"converting coordinates\")\nfor attr, (_, _, units, standard_name) in self.coords.items():\ncoords[attr] = (\nattr,\ncoords[attr].m_as(units),\n{\n\"standard_name\": standard_name,\n\"long_name\": standard_name.replace(\"_\", \" \"),\n\"units\": units,\n},\n)\nlogger.debug(\"checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"creating dataset\")\nreturn xr.Dataset(\ndata_vars=data_vars,\ncoords=coords,\nattrs=attrs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.schema.Schema.convert","title":"<code>convert(data_vars, coords, attrs)</code>","text":"<p>Convert input to schema-compliant dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data_vars</code> <code>t.Mapping[str, pint.Quantity]</code> <p>Mapping of data variable names to quantities.</p> required <code>coords</code> <code>t.Mapping[str, pint.Quantity]</code> <p>Mapping of coordinate names to quantities.</p> required <code>attrs</code> <code>t.Mapping[str, str]</code> <p>Mapping of attribute names to values.</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Dataset with schema-compliant data variables, coordinates, and</p> <code>xr.Dataset</code> <p>attributes.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def convert(\nself,\ndata_vars: t.Mapping[str, pint.Quantity],\ncoords: t.Mapping[str, pint.Quantity],\nattrs: t.Mapping[str, str],\n) -&gt; xr.Dataset:\n\"\"\"Convert input to schema-compliant dataset.\n    Args:\n        data_vars: Mapping of data variable names to quantities.\n        coords: Mapping of coordinate names to quantities.\n        attrs: Mapping of attribute names to values.\n    Returns:\n        Dataset with schema-compliant data variables, coordinates, and\n        attributes.\n    \"\"\"\nlogger.debug(\"converting input to schema-compliant dataset\")\nlogger.debug(\"checking that all data variables are present\")\nfor var in self.data_vars:\nif var not in data_vars:\nraise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\nlogger.debug(\"checking that there is at least one x_ data variable\")\nif not any([name.startswith(\"x_\") for name in data_vars]):\nraise ValueError(\"missing data variable starting with x_\")  # pragma: no cover\nlogger.debug(\"checking that all coordinates are present\")\nfor coord in self.coords:\nif coord not in coords:\nraise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\nlogger.debug(\"checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"converting data variables to xarray data array tuples\")\nfor var, (dims, _, units, standard_name) in self.data_vars.items():\ndata_vars[var] = (\ndims,\ndata_vars[var].m_as(units),\n{\n\"standard_name\": standard_name,\n\"long_name\": standard_name.replace(\"_\", \" \"),\n\"units\": units,\n},\n)\nlogger.debug(\"converting x_ data variables\")\nfor var in data_vars:\nif var.startswith(\"x_\"):\nm = var[2:]\ndata_vars[var] = (\n\"z\",\ndata_vars[var].m_as(\"dimensionless\"),\n{\n\"standard_name\": f\"{m}_volume_fraction\",\n\"long_name\": f\"{m} volume fraction\",\n\"units\": \"dimensionless\",\n},\n)\nlogger.debug(\"converting coordinates\")\nfor attr, (_, _, units, standard_name) in self.coords.items():\ncoords[attr] = (\nattr,\ncoords[attr].m_as(units),\n{\n\"standard_name\": standard_name,\n\"long_name\": standard_name.replace(\"_\", \" \"),\n\"units\": units,\n},\n)\nlogger.debug(\"checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"creating dataset\")\nreturn xr.Dataset(\ndata_vars=data_vars,\ncoords=coords,\nattrs=attrs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.schema.Schema.validate","title":"<code>validate(ds, check_volume_fraction_sum=False, ret_true_if_valid=False)</code>","text":"<p>Validate dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>Dataset to validate.</p> required <code>check_volume_fraction_sum</code> <code>bool</code> <p>if True, check that volume fraction sums are never larger than one.</p> <code>False</code> <code>ret_true_if_valid</code> <code>bool</code> <p>make this method return True if the dataset is valid.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset does not match the schema.</p> <p>Returns:</p> Type Description <code>t.Optional[bool]</code> <p>None or bool: If <code>ret_true_if_valid</code> is True, returns True if the  dataset is valid, otherwise returns None.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def validate(\nself,\nds: xr.Dataset,\ncheck_volume_fraction_sum: bool = False,\nret_true_if_valid: bool = False,\n) -&gt; t.Optional[bool]:\n\"\"\"Validate dataset.\n    Args:\n        ds: Dataset to validate.\n        check_volume_fraction_sum: if True, check that volume fraction sums\n            are never larger than one.\n        ret_true_if_valid: make this method return True if the dataset is\n            valid.\n    Raises:\n        ValueError: If the dataset does not match the schema.\n    Returns:\n        None or bool: If `ret_true_if_valid` is True, returns True if the \n            dataset is valid, otherwise returns None.\n    \"\"\"\nlogger.debug(\"Validating dataset\")\nlogger.debug(\"Checking that all data variables are present\")\nfor var in self.data_vars:\nif var not in ds.data_vars:\nraise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\nlogger.debug(\"Checking that 'x_*' data variable(s) are present\")\nif not any([name.startswith(\"x_\") for name in ds.data_vars]):\nraise ValueError(\"missing data variable starting with x_\")  # pragma: no cover\nlogger.debug(\"Checking that all coordinates are present\")\nfor coord in self.coords:\nif coord not in ds.coords:\nraise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\nlogger.debug(\"Checking that all attributes are present\")\nfor attr in self.attrs:\nif attr not in ds.attrs:\nraise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\nlogger.debug(\"Checking that data variables have the correct dimensions\")\nfor var, (dims, _, _, _) in self.data_vars.items():\nif set(ds[var].dims) != set(dims):\nraise ValueError(  # pragma: no cover\nf\"incorrect dimensions for {var}. Expected {dims}, \"\nf\"got {ds[var].dims}\"\n)\nlogger.debug(\"Checking that coordinates have the correct dimensions\")\nfor coord, (dims, _, _, _) in self.coords.items():\nif set(ds[coord].dims) != set(dims):\nraise ValueError(  # pragma: no cover\nf\"incorrect dimensions for {coord}. Expected {dims}, \"\nf\"got {ds[coord].dims}\"\n)\nlogger.debug(\"Checking that data variables have the correct units\")\nfor var, (_, _, units, _) in self.data_vars.items():\nif ds[var].units != units:\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {var}. Expected {units}, \"\nf\"got {ds[var].units}\"\n)\nlogger.debug(\"Checking that coordinates have the correct units\")\nfor coord, (_, _, units, _) in self.coords.items():\nif ds[coord].units != units:\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {coord}. Expected {units}, \"\nf\"got {ds[coord].units}\"\n)\nlogger.debug(\"Checking that attributes have the correct types\")\nfor attr, typ in self.attrs.items():\nif not isinstance(ds.attrs[attr], typ):\nraise ValueError(  # pragma: no cover\nf\"incorrect type for {attr}. Expected {typ}, \"\nf\"got {type(ds.attrs[attr])}\"\n)\nlogger.debug(\"Checking that data variables have the correct standard names\")\nfor var, (_, _, _, standard_name) in self.data_vars.items():\nif ds[var].attrs[\"standard_name\"] != standard_name:\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {var}. Expected \"\nf\"{standard_name}, got \"\nf\"{ds[var].attrs['standard_name']}\"\n)\nlogger.debug(\"Checking that coordinates have the correct standard names\")\nfor coord, (_, _, _, standard_name) in self.coords.items():\nif ds[coord].attrs[\"standard_name\"] != standard_name:\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {coord}. Expected \"\nf\"{standard_name}, got \"\nf\"{ds[coord].attrs['standard_name']}\"\n)\nlogger.debug(\n\"Checking that all x_* data variables have the correct units and \"\n\"standard names\"\n)\nfor var in ds.data_vars:\nif var.startswith(\"x_\"):\nm = var[2:]\nif ds[var].attrs[\"units\"] != \"dimensionless\":\nraise ValueError(  # pragma: no cover\nf\"incorrect units for {var}. Expected dimensionless, \"\nf\"got {ds[var].attrs['units']}\"\n)\nif ds[var].attrs[\"standard_name\"] != f\"{m}_volume_fraction\":\nraise ValueError(  # pragma: no cover\nf\"incorrect standard name for {var}. Expected \"\nf\"{m}_volume_fraction, got \"\nf\"{ds[var].attrs['standard_name']}\"\n)\nif check_volume_fraction_sum:\nlogger.debug(\n\"Checking that volume fraction sums are never larger than one\"\n)\nvfs = volume_fraction_sum(ds)\nif np.any(vfs.m &gt; 1):\nraise ValueError(\n\"The rescaling factors lead to a profile where the volume \"\n\"fraction sum is larger than 1.\"\n)\nlogger.info(\"Dataset is valid\")\nif ret_true_if_valid:  # pragma: no cover\nreturn True\n</code></pre>"},{"location":"reference/#src.joseki.profiles.schema.volume_fraction_sum","title":"<code>volume_fraction_sum(ds)</code>","text":"<p>Compute the sum of volume mixing fractions.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>Dataset.</p> required <p>Returns:</p> Type Description <code>pint.Quantity</code> <p>The sum of volume fractions.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def volume_fraction_sum(ds: xr.Dataset) -&gt; pint.Quantity:\n\"\"\"Compute the sum of volume mixing fractions.\n    Args:\n        ds: Dataset.\n    Returns:\n        The sum of volume fractions.\n    \"\"\"\nreturn (\nsum([ds[c] for c in ds.data_vars if c.startswith(\"x_\")]).values\n* ureg.dimensionless\n)\n</code></pre>"},{"location":"reference/#afgl-1986","title":"AFGL (1986)","text":"<p>AFGL 1986 atmosphere's thermophysical profiles.</p> <p>The profiles are generated from data files stored in <code>joseki/data/afgl_1986</code>. These data files correspond to tables 1a-f and 2a-d of the technical report [@Anderson1986AtmosphericConstituentProfiles].</p>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986MidlatitudeSummer","title":"<code>AFGL1986MidlatitudeSummer</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 midlatitude summer atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-midlatitude_summer\")\n@define\nclass AFGL1986MidlatitudeSummer(Profile):\n\"\"\"AFGL 1986 midlatitude summer atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 midlatitude summer atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.MIDLATITUDE_SUMMER,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986MidlatitudeWinter","title":"<code>AFGL1986MidlatitudeWinter</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 midlatitude winter atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-midlatitude_winter\")\n@define\nclass AFGL1986MidlatitudeWinter(Profile):\n\"\"\"AFGL 1986 midlatitude winter atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 midlatitude winter atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.MIDLATITUDE_WINTER,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986SubarcticSummer","title":"<code>AFGL1986SubarcticSummer</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 subarctic summer atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-subarctic_summer\")\n@define\nclass AFGL1986SubarcticSummer(Profile):\n\"\"\"AFGL 1986 subarctic summer atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 subarctic summer atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.SUBARCTIC_SUMMER,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986SubarcticWinter","title":"<code>AFGL1986SubarcticWinter</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 subarctic winter atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-subarctic_winter\")\n@define\nclass AFGL1986SubarcticWinter(Profile):\n\"\"\"AFGL 1986 subarctic winter atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 subarctic winter atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.SUBARCTIC_WINTER,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986Tropical","title":"<code>AFGL1986Tropical</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 tropical atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-tropical\")\n@define\nclass AFGL1986Tropical(Profile):\n\"\"\"AFGL 1986 tropical atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 tropical atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.TROPICAL,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.AFGL1986USStandard","title":"<code>AFGL1986USStandard</code>","text":"<p>         Bases: <code>Profile</code></p> <p>AFGL 1986 US Standard atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-us_standard\")\n@define\nclass AFGL1986USStandard(Profile):\n\"\"\"AFGL 1986 US Standard atmosphere thermophysical profile.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nlogger.debug(\n\"creating AFGL 1986 US Standard atmosphere thermophysical profile data set.\"\n)\nreturn to_dataset(\nidentifier=Identifier.US_STANDARD,\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.Identifier","title":"<code>Identifier</code>","text":"<p>         Bases: <code>enum.Enum</code></p> <p>AFGL 1986 atmospheric profile identifier enumeration.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>class Identifier(enum.Enum):\n\"\"\"AFGL 1986 atmospheric profile identifier enumeration.\"\"\"\nTROPICAL = \"tropical\"\nMIDLATITUDE_SUMMER = \"midlatitude_summer\"\nMIDLATITUDE_WINTER = \"midlatitude_winter\"\nSUBARCTIC_SUMMER = \"subarctic_summer\"\nSUBARCTIC_WINTER = \"subarctic_winter\"\nUS_STANDARD = \"us_standard\"\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.dataframe_to_dataset","title":"<code>dataframe_to_dataset(df, identifier, additional_molecules=True)</code>","text":"<p>Convert the output of the <code>parse</code> method to a <code>xarray.Dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Atmospheric profile data.</p> required <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier.</p> required <code>additional_molecules</code> <code>bool</code> <p>If <code>True</code>, include molecules 8-28 as numbered  in [@Anderson1986AtmosphericConstituentProfiles]. Else, discard molecules 8-28.</p> <code>True</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Atmospheric profile data set.</p> Notes <p>Use the <code>z</code> column of the output pandas.DataFrame of read_raw_data as data coordinate and all other columns as data variables. All data variables and coordinates of the returned xarray.Dataset are associated metadata (standard name, long name and units). Raw data units are documented in the technical report AFGL Atmospheric Constituent Profiles (0-120 km), Anderson et al., 1986 [@Anderson1986AtmosphericConstituentProfiles]. Data set attributes are added.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def dataframe_to_dataset(\ndf: pd.DataFrame,\nidentifier: Identifier,\nadditional_molecules: bool = True,\n) -&gt; xr.Dataset:\n\"\"\"Convert the output of the `parse` method to a `xarray.Dataset`.\n    Args:\n        df: Atmospheric profile data.\n        identifier: Atmospheric profile identifier.\n        additional_molecules: If ``True``, include molecules 8-28 as numbered \n            in [@Anderson1986AtmosphericConstituentProfiles].\n            Else, discard molecules 8-28.\n    Returns:\n        Atmospheric profile data set.\n    Notes:\n        Use the ``z`` column of the output pandas.DataFrame of read_raw_data\n        as data coordinate and all other columns as data variables.\n        All data variables and coordinates of the returned xarray.Dataset are\n        associated metadata (standard name, long name and units).\n        Raw data units are documented in the technical report *AFGL Atmospheric\n        Constituent Profiles (0-120 km)*, Anderson et al., 1986\n        [@Anderson1986AtmosphericConstituentProfiles].\n        Data set attributes are added.\n    \"\"\"\n# list molecules\n# molecules labels correspond to column with upper case first letter in\n# raw data DataFrames\nmolecules = []\nfor column in df.columns:\nif column[0].isupper():\nmolecules.append(column)\nif additional_molecules:\npass\nelse:\nmolecules = molecules[:7]\n# coordinates\ncoords = {\"z\": ureg.Quantity(df.z.values, \"km\")}\n# data variables\ndata_vars = {}\ndata_vars[\"p\"] = ureg.Quantity(df.p.values, \"millibar\").to(\"Pa\")\ndata_vars[\"t\"] = ureg.Quantity(df.t.values, \"K\")\ndata_vars[\"n\"] = ureg.Quantity(df.n.values, \"cm^-3\").to(\"m^-3\")\nfor s in molecules:\ndata_vars[f\"x_{s}\"] = (\ndf[s].values * ureg.ppm\n)  # raw data volume fraction are given in ppmv\n# attributes\npretty_identifier = f\"AFGL (1986) {identifier.value.replace('_', '-')}\"\npretty_title = f\"{pretty_identifier} atmosphere thernmophysical profile\"\nattrs = {\n\"Conventions\": \"CF-1.10\",\n\"title\": pretty_title,\n\"institution\": INSTITUION,\n\"source\": SOURCE,\n\"history\": history(),\n\"references\": REFERENCE,\n\"url\": URL,\n\"urldate\": URLDATE,\n}\nreturn schema.convert(\ndata_vars=data_vars,\ncoords=coords,\nattrs=attrs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.get_dataset","title":"<code>get_dataset(identifier, additional_molecules=True)</code>","text":"<p>Read data files for a given atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See  <code>Identifier</code>  for possible values.</p> required <code>additional_molecules</code> <code>bool</code> <p>If <code>True</code>, include molecules 8-28 as numbered in [@Anderson1986AtmosphericConstituentProfiles]. Else, discard molecules 8-28.</p> <code>True</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Atmospheric profile data set.</p> Notes <p>Chain calls to  <code>parse</code> and <code>dataframe_to_dataset</code>.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def get_dataset(\nidentifier: Identifier,\nadditional_molecules: bool = True,\n) -&gt; xr.Dataset:\n\"\"\"Read data files for a given atmospheric profile.\n    Args:\n        identifier: Atmospheric profile identifier.\n            See \n            [`Identifier`](reference.md#src.joseki.profiles.afgl_1986.Identifier) \n            for possible values.\n        additional_molecules: If ``True``, include molecules 8-28 as numbered in\n            [@Anderson1986AtmosphericConstituentProfiles].\n            Else, discard molecules 8-28.\n    Returns:\n        Atmospheric profile data set.\n    Notes:\n        Chain calls to \n        [`parse`](reference.md#src.joseki.profiles.afgl_1986.parse) and\n        [`dataframe_to_dataset`](reference.md#src.joseki.profiles.afgl_1986.dataframe_to_dataset).\n    \"\"\"\ndf = parse(identifier=identifier)\nreturn dataframe_to_dataset(\ndf=df,\nidentifier=identifier,\nadditional_molecules=additional_molecules,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.parse","title":"<code>parse(identifier)</code>","text":"<p>Parse table data files for a given atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Atmospheric profile data set.</p> Notes <p>Read the relevant raw data files corresponding to the atmospheric profile. These raw data files correspond to tables 1 and 2 from the technical report AFGL Atmospheric Constituent Profiles (0-120 km), Anderson et al., 1986 [@Anderson1986AtmosphericConstituentProfiles]. Each atmospheric profile has 5 tables, i.e. 5 raw data files, associated to it. Only the first of these tables is specific to each atmospheric profile. All 5 raw data files are read into <code>pandas.DataFrame</code> objects and then concatenated after dropping the duplicate columns.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def parse(identifier: Identifier) -&gt; pd.DataFrame:\n\"\"\"Parse table data files for a given atmospheric profile.\n    Args:\n        identifier: Atmospheric profile identifier.\n    Returns:\n        Atmospheric profile data set.\n    Notes:\n        Read the relevant raw data files corresponding to the atmospheric profile.\n        These raw data files correspond to tables 1 and 2 from the\n        technical report *AFGL Atmospheric Constituent Profiles (0-120 km)*,\n        Anderson et al., 1986\n        [@Anderson1986AtmosphericConstituentProfiles].\n        Each atmospheric profile has 5 tables, i.e. 5 raw data files, associated\n        to it.\n        Only the first of these tables is specific to each atmospheric profile.\n        All 5 raw data files are read into `pandas.DataFrame` objects and\n        then concatenated after dropping the duplicate columns.\n    \"\"\"\nfiles = DATA_FILES[identifier]\ndataframes = []\nfor file in files:\nwith pkg_resources.path(afgl_1986, file) as path:\ndataframes.append(pd.read_csv(path))\ndataframes[1] = dataframes[1].drop([\"H2O\", \"O3\", \"N2O\", \"CO\", \"CH4\"], axis=1)\nfor i in range(1, 5):\ndataframes[i] = dataframes[i].drop(\"z\", axis=1)\nreturn pd.concat(dataframes, axis=1)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.afgl_1986.to_dataset","title":"<code>to_dataset(identifier, z=None, interp_method=None, **kwargs)</code>","text":"<p>Helper Profile.to_dataset() method.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>AFGL 1986 atmosphere thermophysical profile identifier. See  <code>Identifier</code>  for possible values.</p> required <code>z</code> <code>t.Optional[pint.Quantity]</code> <p>New level altitudes. If <code>None</code>, return the original data set. Else, interpolate the data set to the new level altitudes. Default is <code>None</code>.</p> <code>None</code> <code>interp_method</code> <code>t.Mapping[str, str]</code> <p>dict, optional Interpolation method for each data variable. Default is <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>t.Any</code> <p>str Additional arguments passed to  <code>get_dataset</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Atmosphere thermophysical profile data set.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def to_dataset(\nidentifier: Identifier,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Mapping[str, str] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n\"\"\"\n    Helper Profile.to_dataset() method.\n    Args:\n        identifier: AFGL 1986 atmosphere thermophysical profile identifier.\n            See \n            [`Identifier`](reference.md#src.joseki.profiles.afgl_1986.Identifier) \n            for possible values.\n        z: New level altitudes.\n            If ``None``, return the original data set.\n            Else, interpolate the data set to the new level altitudes.\n            Default is ``None``.\n        interp_method: dict, optional\n            Interpolation method for each data variable.\n            Default is ``None``.\n        kwargs: str\n            Additional arguments passed to \n            [`get_dataset`](reference.md#src.joseki.profiles.afgl_1986.get_dataset).\n    Returns:\n        Atmosphere thermophysical profile data set.\n    \"\"\"\n# Get additional_molecules from kwargs\nadditional_molecules = kwargs.get(\"additional_molecules\", True)\n# kwargs different than 'additional_molecules' are ignored\nif len([x for x in kwargs.keys() if x != \"additional_molecules\"]) &gt; 0:\nlogger.warning(\n\"Ignoring kwargs different than 'additional_molecules'. \"\n\"(got %s)\"\n\"Use 'additional_molecules' to include molecules 8-28 \"\n\"as numbered in Anderson et al. (1986).\",\nkwargs,\n)\n# Get the original dataset\nds = get_dataset(\nidentifier=identifier,\nadditional_molecules=additional_molecules,\n)\n# Interpolate if necessary\nif z is not None:\nmethod = interp_method if interp_method is not None else DEFAULT_METHOD\nds = interp(ds=ds, z_new=z, method=method)\nreturn ds\nelse:\nreturn ds\n</code></pre>"},{"location":"reference/#mipas-2007","title":"MIPAS (2007)","text":"<p>MIPAS atmosphere thermophysical profiles.</p> <p>Remedios, John J. et al. (2007) define a set of 5 \"standard atmospheres\" representing the atmosphere at different latitudes and seasons or times of day:</p> <ul> <li>midlatitude day</li> <li>midlatitude night</li> <li>polar winter</li> <li>polar summer</li> <li>tropical</li> </ul> <p>MIPAS standard atmospheres were intended to provide an updated set of pro- files for characteristic atmospheric states such as [@Anderson1986AtmosphericConstituentProfiles].</p>"},{"location":"reference/#src.joseki.profiles.mipas_2007.Identifier","title":"<code>Identifier</code>","text":"<p>         Bases: <code>enum.Enum</code></p> <p>MIPAS atmosphere thermophysical profile identifier enumeration.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>class Identifier(enum.Enum):\n\"\"\"MIPAS atmosphere thermophysical profile identifier enumeration.\"\"\"\nMIDLATITUDE_DAY = \"midlatitude_day\"\nMIDLATITUDE_NIGHT = \"midlatitude_night\"\nPOLAR_WINTER = \"polar_winter\"\nPOLAR_SUMMER = \"polar_summer\"\nTROPICAL = \"tropical\"\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.MIPASMidlatitudeDay","title":"<code>MIPASMidlatitudeDay</code>","text":"<p>         Bases: <code>Profile</code></p> <p>MIPAS midlatitude day reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-midlatitude_day\")\n@define\nclass MIPASMidlatitudeDay(Profile):\n\"\"\"MIPAS midlatitude day reference atmosphere.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nreturn to_dataset(\nidentifier=Identifier.MIDLATITUDE_DAY,\nz=z,\nmethod=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.MIPASMidlatitudeNight","title":"<code>MIPASMidlatitudeNight</code>","text":"<p>         Bases: <code>Profile</code></p> <p>MIPAS Midlatitude night reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-midlatitude_night\")\n@define\nclass MIPASMidlatitudeNight(Profile):\n\"\"\"MIPAS Midlatitude night reference atmosphere.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nreturn to_dataset(\nidentifier=Identifier.MIDLATITUDE_NIGHT,\nz=z,\nmethod=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.MIPASPolarSummer","title":"<code>MIPASPolarSummer</code>","text":"<p>         Bases: <code>Profile</code></p> <p>MIPAS Polar summer reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-polar_summer\")\n@define\nclass MIPASPolarSummer(Profile):\n\"\"\"MIPAS Polar summer reference atmosphere.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nreturn to_dataset(\nidentifier=Identifier.POLAR_SUMMER,\nz=z,\nmethod=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.MIPASPolarWinter","title":"<code>MIPASPolarWinter</code>","text":"<p>         Bases: <code>Profile</code></p> <p>MIPAS Polar winter reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-polar_winter\")\n@define\nclass MIPASPolarWinter(Profile):\n\"\"\"MIPAS Polar winter reference atmosphere.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nreturn to_dataset(\nidentifier=Identifier.POLAR_WINTER,\nz=z,\nmethod=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.MIPASTropical","title":"<code>MIPASTropical</code>","text":"<p>         Bases: <code>Profile</code></p> <p>MIPAS Tropical reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-tropical\")\n@define\nclass MIPASTropical(Profile):\n\"\"\"MIPAS Tropical reference atmosphere.\"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\nreturn to_dataset(\nidentifier=Identifier.TROPICAL,\nz=z,\nmethod=interp_method,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.get_dataset","title":"<code>get_dataset(identifier)</code>","text":"<p>Read MIPAS reference atmosphere data files into an xarray.Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See  <code>Identifier</code>  for possible values.</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Atmospheric profile.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def get_dataset(identifier: Identifier) -&gt; xr.Dataset:\n\"\"\"Read MIPAS reference atmosphere data files into an xarray.Dataset.\n    Args:\n        identifier: Atmospheric profile identifier.\n            See \n            [`Identifier`](reference.md#src.joseki.profiles.mipas_2007.Identifier) \n            for possible values.\n    Returns:\n        Atmospheric profile.\n    \"\"\"\ncontent = read_file_content(identifier=identifier)\nquantities = parse_content(content.splitlines())\n# Coordinates\ncoords = {\"z\": quantities.pop(\"z\")}\n# Data variables\ndata_vars = {}\np = quantities.pop(\"p\")\ndata_vars[\"p\"] = p\nt = quantities.pop(\"t\")\ndata_vars[\"t\"] = t\nn = p / (K * t)  # perfect gas equation\ndata_vars[\"n\"] = n\ndata_vars.update(quantities)\nlogger.debug(\"data variables: %s\", data_vars.keys())\n# Attributes\npretty_id = identifier.value.replace(\"_\", \" \")\npretty_title = f\"MIPAS {pretty_id} Reference Atmosphere\"\nattrs = {\n\"Conventions\": \"CF-1.10\",\n\"history\": history(),\n\"title\": pretty_title,\n\"source\": SOURCE,\n\"institution\": INSTITUTION,\n\"references\": REFERENCE,\n\"url\": URL,\n\"urldate\": URL_DATE,\n}\n# Dataset\nds = schema.convert(\ndata_vars=data_vars,\ncoords=coords,\nattrs=attrs,\n)\nreturn ds\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.parse_content","title":"<code>parse_content(lines)</code>","text":"<p>Parse lines.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_content(lines: t.List[str]) -&gt; t.Dict[str, pint.Quantity]:\n\"\"\"Parse lines.\"\"\"\nlogger.debug(\"Parsing file content\")\niterator = iter(lines)\nline = next(iterator)\nquantities: t.Dict[str, pint.Quantity] = {}\ndef _add_to_quantities(quantity: pint.Quantity, name: str) -&gt; None:\nif name not in [\"z\", \"p\", \"t\", \"n\"]:\nname = f\"x_{name}\"\nif quantity.check(\"\"):\nquantities[name] = quantity.to(\"dimensionless\")\nelse:\nquantities[name] = quantity\nvar: str = \"\"\nunits: str = \"\"\nvalues: t.List[str] = []\nwhile line != \"*END\":\nif line.startswith(\"!\"):\npass  # this is a comment, ignore the line\nelif line.startswith(\"*\"):\n# convert previously read values (if any) and units to quantity\nif len(values) &gt; 0:\nquantity = ureg.Quantity(\nnp.array(values, dtype=float),\nunits,\n)\n_add_to_quantities(quantity=quantity, name=var)\n# this is a variable line, parse variable name and units\nvar, units = parse_var_line(line)\n# following lines are the variables values so prepare a variable\n# to store the values\nvalues = []\nelse:\nif \"!\" in line:\n# this the line with the number of profile levels, ignore it\npass\nelse:\n# this line contains variable values\nvalues += parse_values_line(line)\nline = next(iterator)\n# include last array of values before the '*END' line\nquantity = ureg.Quantity(np.array(values, dtype=float), units)\n_add_to_quantities(quantity=quantity, name=var)\nreturn quantities\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.parse_units","title":"<code>parse_units(s)</code>","text":"<p>Parse units.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_units(s: str) -&gt; str:\n\"\"\"Parse units.\"\"\"\nif s.startswith(\"[\") and s.endswith(\"]\"):\nunits = s[1:-1]\nif units == \"mb\":\nreturn \"millibar\"\nelse:\nreturn units\nelse:\nraise ValueError(f\"Cannot parse units '{s}'\")\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.parse_values_line","title":"<code>parse_values_line(s)</code>","text":"<p>Parse a line with numeric values.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_values_line(s: str) -&gt; t.List[str]:\n\"\"\"Parse a line with numeric values.\"\"\"\nif \",\" in s:  # delimiter is comma and whitespace combined\ns_strip = s.strip()\nif s_strip[-1] == \",\":\ns_strip = s_strip[:-1]\nreturn [x.strip() for x in s_strip.split(\",\")]\nelse:  # delimiter is whitespace\nreturn s.split()\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.parse_var_line","title":"<code>parse_var_line(s)</code>","text":"<p>Parse a line with the declaration of a variable and its units.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_var_line(s: str) -&gt; t.Tuple[str, str]:\n\"\"\"Parse a line with the declaration of a variable and its units.\"\"\"\nparts = s[1:].strip().split()\nif len(parts) == 2:\nvar_name, units_s = parts\nelif len(parts) == 3:\nvar_name, _, units_s = parts\nelse:\nraise ValueError(f\"Invalid line format: {s}\")\nvar = parse_var_name(var_name)\nunits = parse_units(units_s)\nreturn var, units\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.parse_var_name","title":"<code>parse_var_name(n)</code>","text":"<p>Parse variable name.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_var_name(n: str) -&gt; str:\n\"\"\"Parse variable name.\"\"\"\ntranslate = {\"HGT\": \"z\", \"PRE\": \"p\", \"TEM\": \"t\"}\nif n in translate.keys():\nreturn translate[n]\nelse:\nreturn to_chemical_formula(n)\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.read_file_content","title":"<code>read_file_content(identifier)</code>","text":"<p>Read data file content.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See  <code>Identifier</code>  for possible values.</p> required <p>Returns:</p> Type Description <code>str</code> <p>file content, URL, URL date.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def read_file_content(identifier: Identifier) -&gt; str:\n\"\"\"\n    Read data file content.\n    Args:\n        identifier: Atmospheric profile identifier.\n            See \n            [`Identifier`](reference.md#src.joseki.profiles.mipas_2007.Identifier) \n            for possible values.\n    Returns:\n        file content, URL, URL date.\n    \"\"\"\nfile = f\"{identifier.value}.atm\"\nlogger.debug(f\"Reading file {file}\")\nwith pkg_resources.path(mipas_2007, file) as path:\nwith open(path, \"r\") as f:\ncontent = f.read()\nreturn content\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.to_chemical_formula","title":"<code>to_chemical_formula(name)</code>","text":"<p>Convert to chemical formula.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Molecule name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Molecule formula.</p> Notes <p>If molecule name is unknown, returns name unchanged.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def to_chemical_formula(name: str) -&gt; str:\n\"\"\"Convert to chemical formula.\n    Args:\n        name: Molecule name.\n    Returns:\n        Molecule formula.\n    Notes:\n        If molecule name is unknown, returns name unchanged.\n    \"\"\"\ntry:\nreturn translate_cfc(name)\nexcept ValueError:\nreturn name\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.to_dataset","title":"<code>to_dataset(identifier, z=None, method=None, **kwargs)</code>","text":"<p>Helper for <code>Profile.to_dataset</code> method</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def to_dataset(\nidentifier: Identifier,\nz: t.Optional[pint.Quantity] = None,\nmethod: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n\"\"\"Helper for `Profile.to_dataset` method\"\"\"\n# no kwargs are expected\nif len(kwargs) &gt; 0:  # pragma: no cover\nlogger.warning(\"Unexpected keyword arguments: %s\", kwargs)\n# get original MIPAS midlatitude day reference atmosphere\nlogger.debug(\"Get original MIPAS midlatitude day reference atmosphere\")\nds = get_dataset(identifier=identifier)\n# Interpolate to new vertical grid if necessary\nif z is not None:\nmethod = DEFAULT_METHOD if method is None else method\nds = interp(ds=ds, z_new=z, method=method)\nreturn ds\nelse:\nreturn ds\n</code></pre>"},{"location":"reference/#src.joseki.profiles.mipas_2007.translate_cfc","title":"<code>translate_cfc(name)</code>","text":"<p>Convert chlorofulorocarbon name to corresponding chemical formula.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Chlorofulorocarbon name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Chlorofulorocarbon chemical formula.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name does not match a known chlorofulorocarbon.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def translate_cfc(name: str) -&gt; str:\n\"\"\"Convert chlorofulorocarbon name to corresponding chemical formula.\n    Args:\n        name: Chlorofulorocarbon name.\n    Returns:\n        Chlorofulorocarbon chemical formula.\n    Raises:\n        ValueError: If the name does not match a known chlorofulorocarbon.\n    \"\"\"\nfor formula, names in CFC_FORMULAE.items():\nif name in names:\nreturn formula\nraise ValueError(\"Unknown chlorofulorocarbon {name}\")\n</code></pre>"},{"location":"reference/#us-standard-atmosphere-1976","title":"US Standard Atmosphere (1976)","text":"<p>Module to compute the U.S. Standard Atmosphere 1976.</p> <p>The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model  described in the technical report [@NASA1976USStandardAtmosphere].</p>"},{"location":"reference/#src.joseki.profiles.ussa_1976.USSA1976","title":"<code>USSA1976</code>","text":"<p>         Bases: <code>Profile</code></p> <p>Class to compute the U.S. Standard Atmosphere 1976.</p> <p>The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model described in the technical report [@NASA1976USStandardAtmosphere].</p> Source code in <code>src/joseki/profiles/ussa_1976.py</code> <pre><code>@factory.register(identifier=\"ussa_1976\")\n@define\nclass USSA1976(Profile):\n\"\"\"\n    Class to compute the U.S. Standard Atmosphere 1976.\n    The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model\n    described in the technical report [@NASA1976USStandardAtmosphere].\n    \"\"\"\ndef to_dataset(\nself,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = None,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n# interpolation is not required\nif interp_method is not None:\nlogger.warning(  # pragma: no cover\n\"interpolation is not required. The value of the \"\n\"'interp_method' parameter will be ignored.\"\n)\n# kwargs are ignored\nif kwargs:\nlogger.warning(  # pragma: no cover\n\"value of the 'kwargs' parameter will be ignored.\"\n)\n# variable to compute with the ussa1976 package\nvariables = [\n\"p\",\n\"t\",\n\"n_tot\",\n\"n\",\n]\n# compute profile\nif z is None:\nlogging.debug(\"Computing profile with ussa1976 package\")\nds = ussa1976.compute(variables=variables)\nelse:\nlogging.debug(\"Computing profile with ussa1976 package\")\nlogging.debug(\"z=%s\", z)\nds = ussa1976.compute(z=z.m_as(\"m\"), variables=variables)\n# extract data\ncoords = {\"z\": to_quantity(ds[\"z\"]).to(\"km\")}\ndata_vars = {}\ndata_vars[\"p\"] = to_quantity(ds[\"p\"]).to(\"Pa\")\ndata_vars[\"t\"] = to_quantity(ds[\"t\"]).to(\"K\")\ndata_vars[\"n\"] = to_quantity(ds[\"n_tot\"]).to(\"m^-3\")\n# compute volume fraction\nfor s in ds[\"s\"].values:\nnx = to_quantity(ds[\"n\"].sel(s=s))\nn_tot = to_quantity(ds[\"n_tot\"])\ndata_vars[f\"x_{s}\"] = (nx / n_tot).to(\"dimensionless\")\nattrs = {\n\"Conventions\": \"CF-1.10\",\n\"title\": \"U.S. Standard Atmosphere 1976\",\n\"institution\": \"NASA\",\n\"source\": ds.attrs[\"source\"],\n\"history\": ds.attrs[\"history\"] + \"\\n\" + history(),\n\"references\": ds.attrs[\"references\"],\n\"url\": \"https://ntrs.nasa.gov/citations/19770009539\",\n\"urldate\": \"2022-12-08\",\n}\nds = schema.convert(\ndata_vars,\ncoords,\nattrs,\n)\nreturn ds\n</code></pre>"},{"location":"reference/#command-line-interface","title":"Command line interface","text":"<p>Command-line interface.</p>"},{"location":"reference/#src.joseki.__main__.main","title":"<code>main(file_name, identifier, altitudes, altitude_units, represent_in_cells, p_interp_method, t_interp_method, n_interp_method, x_interp_method)</code>","text":"<p>Joseki command-line interface.</p> Source code in <code>src/joseki/__main__.py</code> <pre><code>@click.command()\n@click.option(\n\"--file-name\",\n\"-f\",\nhelp=\"Output file name.\",\ndefault=\"ds.nc\",\nshow_default=True,\ntype=click.Path(writable=True),\n)\n@click.option(\n\"--identifier\",\n\"-i\",\nhelp=\"Atmospheric profile identifier.\",\nrequired=True,\ntype=click.Choice(\nchoices=IDENTIFIER_CHOICES,\ncase_sensitive=True,\n),\n)\n@click.option(\n\"--altitudes\",\n\"-a\",\nhelp=(\n\"Path to level altitudes data file. The data file is read with \"\n\"pandas.read_csv. The data file must be a column named 'z'.\"\n),\ndefault=None,\nshow_default=True,\n)\n@click.option(\n\"--altitude-units\",\n\"-u\",\nhelp=\"Altitude units\",\ndefault=\"km\",\nshow_default=True,\n)\n@click.option(\n\"--represent-in-cells\",\n\"-r\",\nhelp=(\n\"Compute the cells representation of the atmospheric profile. The \"\n\"initial altitude values are used to define the altitude bounds of \"\n\"each cell. The pressure, temperature, number density and mixing \"\n\"ratio fields are interpolated at the cells' center altitudes.\"\n),\nis_flag=True,\n)\n@click.option(\n\"--p-interp-method\",\n\"-p\",\nhelp=\"Pressure interpolation method.\",\ntype=click.Choice(\nINTERPOLATION_METHOD_CHOICES,\ncase_sensitive=True,\n),\ndefault=\"linear\",\nshow_default=True,\n)\n@click.option(\n\"--t-interp-method\",\n\"-t\",\nhelp=\"Temperature interpolation method.\",\ntype=click.Choice(\nINTERPOLATION_METHOD_CHOICES,\ncase_sensitive=True,\n),\ndefault=\"linear\",\nshow_default=True,\n)\n@click.option(\n\"--n-interp-method\",\n\"-n\",\nhelp=\"Number density interpolation method.\",\ntype=click.Choice(\nINTERPOLATION_METHOD_CHOICES,\ncase_sensitive=True,\n),\ndefault=\"linear\",\nshow_default=True,\n)\n@click.option(\n\"--x-interp-method\",\n\"-x\",\nhelp=\"Volume mixing ratios interpolation method.\",\ntype=click.Choice(\nINTERPOLATION_METHOD_CHOICES,\ncase_sensitive=True,\n),\ndefault=\"linear\",\nshow_default=True,\n)\n@click.version_option()\ndef main(\nfile_name: str,\nidentifier: str,\naltitudes: t.Optional[str],\naltitude_units: str,\nrepresent_in_cells: bool,\np_interp_method: str,\nt_interp_method: str,\nn_interp_method: str,\nx_interp_method: str,\n) -&gt; None:\n\"\"\"Joseki command-line interface.\"\"\"\n# read altitude grid\nif altitudes is not None:\ndf = pd.read_csv(pathlib.Path(altitudes))\nz = df[\"z\"].values * ureg(altitude_units)\nelse:\nz = None\n# make data set\nds = make(\nidentifier=identifier,\nz=z,\np_interp_method=p_interp_method,\nt_interp_method=t_interp_method,\nn_interp_method=n_interp_method,\nx_interp_method=x_interp_method,\nrepresent_in_cells=represent_in_cells,\n)\n# write data set\nds.to_netcdf(file_name)\n</code></pre>"},{"location":"reference/#core_1","title":"Core","text":"<p>Core module.</p>"},{"location":"reference/#src.joseki.core.make","title":"<code>make(identifier, z=None, interp_method=DEFAULT_METHOD, represent_in_cells=False, **kwargs)</code>","text":"<p>Create a profile.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <code>z</code> <code>t.Optional[pint.Quantity]</code> <p>Altitude values.</p> <code>None</code> <code>interp_method</code> <code>t.Optional[t.Mapping[str, str]]</code> <p>Mapping of variable and interpolation method.</p> <code>DEFAULT_METHOD</code> <code>represent_in_cells</code> <code>bool</code> <p>If <code>True</code>, compute the altitude layer centers and  interpolate the profile on the layer centers, and return the  interpolated profile.</p> <code>False</code> <code>kwargs</code> <code>t.Any</code> <p>Additional keyword arguments passed to the profile constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>Profile as xarray.Dataset.</p> Source code in <code>src/joseki/core.py</code> <pre><code>def make(\nidentifier: str,\nz: t.Optional[pint.Quantity] = None,\ninterp_method: t.Optional[t.Mapping[str, str]] = DEFAULT_METHOD,\nrepresent_in_cells: bool = False,\n**kwargs: t.Any,\n) -&gt; xr.Dataset:\n\"\"\"\n    Create a profile.\n    Args:\n        identifier: Profile identifier.\n        z: Altitude values.\n        interp_method: Mapping of variable and interpolation method.\n        represent_in_cells: If `True`, compute the altitude layer centers and \n            interpolate the profile on the layer centers, and return the \n            interpolated profile.\n        kwargs: Additional keyword arguments passed to the profile constructor.\n    Returns:\n        Profile as xarray.Dataset.\n    \"\"\"\nlogger.info(\"Creating profile %s\", identifier)\nlogger.debug(\"profile: %s\", identifier)\nlogger.debug(\"z: %s\", z)\nlogger.debug(\"interp_method: %s\", interp_method)\nlogger.debug(\"represent_in_cells: %s\", represent_in_cells)\nlogger.debug(\"kwargs: %s\", kwargs)\nprofile = factory.create(identifier)\nlogger.debug(\"exporting profile to xarray.Dataset\")\nds = profile.to_dataset(\nz=z,\ninterp_method=interp_method,\n**kwargs,\n)\nif represent_in_cells:\nlogger.debug(\"representing profile in cells\")\nds = represent_profile_in_cells(ds, method=interp_method)\nreturn ds\n</code></pre>"},{"location":"reference/#units","title":"Units","text":"<p>Units module.</p>"},{"location":"reference/#src.joseki.units.to_quantity","title":"<code>to_quantity(da)</code>","text":"<p>Convert a <code>xarray.DataArray</code> to a <code>pint.Quantity</code>.</p> Notes <p>The array's <code>attrs</code> metadata mapping must contain a <code>units</code> field. This function can also be used on coordinate variables.</p> <p>Parameters:</p> Name Type Description Default <code>da</code> <code>xr.DataArray</code> <p>xarray.DataArray instance which will be converted.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>xarray.DataArray</code>'s <code>`attrs</code> field does not  contain a <code>units</code> key.</p> <p>Returns:</p> Type Description <code>pint.Quantity</code> <p>The corresponding quantity.</p> Source code in <code>src/joseki/units.py</code> <pre><code>def to_quantity(da: xr.DataArray) -&gt; pint.Quantity:\n\"\"\"Convert a `xarray.DataArray` to a `pint.Quantity`.\n    Notes:\n        The array's `attrs` metadata mapping must contain a `units` field.\n        This function can also be used on coordinate variables.\n    Args:\n        da: xarray.DataArray instance which will be converted.\n    Raises:\n        ValueError: If the `xarray.DataArray`'s ``attrs` field does not \n            contain a `units` key.\n    Returns:\n        The corresponding quantity.\n    \"\"\"\ntry:\nunits = da.attrs[\"units\"]\nexcept KeyError as e:\nraise ValueError(\"this DataArray has no 'units' metadata field\") from e\nelse:\nreturn ureg.Quantity(da.values, units)\n</code></pre>"},{"location":"reference/#util","title":"Util","text":"<p>Utility module.</p>"},{"location":"reference/#src.joseki.profiles.util.utcnow","title":"<code>utcnow()</code>","text":"<p>Get current UTC time.</p> <p>Returns:</p> Type Description <code>str</code> <p>ISO 8601 formatted UTC timestamp.</p> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def utcnow() -&gt; str:\n\"\"\"Get current UTC time.\n    Returns:\n        ISO 8601 formatted UTC timestamp.\n    \"\"\"\nreturn datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n</code></pre>"}]}