{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the <code>joseki</code> documentation","text":""},{"location":"#table-of-contents","title":"Table of contents","text":"<p>The documentation consists of four separate parts:</p> <ul> <li>How-To Guides</li> <li>Explanation</li> <li>Tutorials</li> <li>Reference</li> </ul>"},{"location":"bibliography/","title":"Bibliography","text":"<ul> <li> <p> Anderson, G. P., S. A. Clough, F. X. Kneizys, J. H. Chetwynd, and E. P. Shettle. 1986. \u2018AFGL Atmospheric Constituent Profiles (0.120km)\u2019. AFGL-TR-0208 Environemental Research Papers, May. http://adsabs.harvard.edu/abs/1986afgl.rept.....A.</p> </li> <li> <p> United States National Oceanic and Atmospheric Administration and United States Committee on Extension to the Standard Atmosphere. 1976. \u2018U.S. Standard Atmosphere, 1976\u2019. NOAA-S/T-76-1562. https://ntrs.nasa.gov/citations/19770009539.</p> </li> <li> <p> Remedios, J. J., R. J. Leigh, A. M. Waterfall, D. P. Moore, H. Sembhi, I. Parkes, J. Greenhough, M. P. Chipperfield, and D. Hauglustaine. 2007. \u2018MIPAS Reference Atmospheres and Comparisons to V4.61/V4.62 MIPAS Level 2 Geophysical Data Sets\u2019. Atmospheric Chemistry and Physics Discussions 7 (4): 9973\u201310017. https://doi.org/10.5194/acpd-7-9973-2007.</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project are documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#261-2024-02-13","title":"[2.6.1] - 2024-02-13","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Various documentation tweaks for improved quality of life (search, logo, etc.).</li> <li>Move from PDM to Rye for project management.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Added missing tests to bring coverage metric to 100%.</li> </ul>"},{"location":"changelog/#260-2023-12-14","title":"[2.6.0] - 2023-12-14","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Joseki is now licensed under the terms of the LGPLv3.</li> <li>Updated documentation to reflect licensing and governance changes.</li> <li>Added Python 3.11 and 3.12 to CI matrix: Joseki is now testing with Python 3.8   to 3.12.</li> </ul>"},{"location":"changelog/#252-2023-11-16","title":"[2.5.2] - 2023-11-16","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Unit test for <code>joseki.profiles.schema</code></li> <li>Unit test for <code>joseki.profiles.util</code></li> <li>Unit test for <code>joseki.units</code></li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Remove duplicate definition of 'parts_per_billion' unit   (#356)</li> </ul>"},{"location":"changelog/#251-2023-10-03","title":"[2.5.1] - 2023-10-03","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Logo</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Schema: accept other units for data variables and data coordinates as long as   they match the expected dimensionality</li> <li>Units registry: load unit definitions one by one in a try-except logic</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Accessor <code>is_valid</code> did not return <code>False</code> when a dataset does not comply   with the schema.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Obsolete test data</li> <li>Obsolete documentation figures</li> <li>Obsolete module <code>test_util.py</code></li> </ul>"},{"location":"changelog/#250-2023-09-05","title":"[2.5.0] - 2023-09-05","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Units definition file at <code>data/units.txt</code></li> <li>Quantity conversion for <code>z</code> parameter of <code>make</code>, which makes it possible to   use <code>make</code> with pure Python inputs</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Get unit registry from application and add Joseki required units by loading   a units definition file.</li> <li>Alias <code>ppm</code> in <code>src/joseki/data/units.txt</code></li> </ul>"},{"location":"changelog/#240-2023-08-07","title":"[2.4.0] - 2023-08-07","text":"<p>Yanked release</p>"},{"location":"changelog/#230-2023-07-20","title":"[2.3.0] - 2023-07-20","text":"<p>Yanked release</p>"},{"location":"changelog/#220-2023-07-18","title":"[2.2.0] - 2023-07-18","text":"<p>Yanked release</p>"},{"location":"changelog/#210-2023-02-17","title":"[2.1.0] - 2023-02-17","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Installation instructions for conda</li> <li>All missing HITRAN species</li> <li>Thin wrappers for <code>xarray.open_dataset</code> and <code>xarray.load_dataset</code></li> <li>Convenience method to list available identifiers</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix out-dated command-line interface</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Lower version constraint on Numpy</li> </ul>"},{"location":"changelog/#200-2023-02-14","title":"[2.0.0] - 2023-02-14","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Profile factory</li> <li>Profile dataset schema converter and validator</li> <li>Logging</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Move from Poetry to PDM</li> <li>Re-organize documentation content</li> <li>Move from Sphinx to mkdocs</li> </ul>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#terminology","title":"Terminology","text":""},{"location":"explanation/#column-number-density","title":"Column number density","text":"<p>If \\(n_{\\mathrm{M}} (z)\\) denotes the number density of molecule M at altitude \\(z\\), then the column number density of molecule M is</p> \\[ N_{\\mathrm{M}} = \\int_{0}^{+\\infty} n_{\\mathrm{M}} (z) \\, \\mathrm{d} z \\] <p>Column number density has dimensions of <code>length^-2</code>.</p>"},{"location":"explanation/#column-mass-density","title":"Column mass density","text":"<p>The column mass density is to mass density what column number density is to number density, i.e.,</p> \\[ P_{\\mathrm{M}} = \\int_{0}^{+\\infty} \\rho_{\\mathrm{M}} (z) \\, \\mathrm{d} z \\] <p>where \\(\\rho_{\\mathrm{M}} (z)\\) is the mass density of molecule M at altitude \\(z\\).</p> <p>Mass density is related with number density through:</p> \\[ \\rho_{\\mathrm{M}} = m_{\\mathrm{M}} \\, n_{\\mathrm{M}} \\] <p>where \\(m_{\\mathrm{M}}\\) is the molecular mass of molecule M.</p> <p>Since molecular mass does not change with altitude, we simply have</p> \\[ P_{\\mathrm{M}} = m_{\\mathrm{M}} \\, N_{\\mathrm{M}} \\] <p>Column mass density has dimensions of <code>mass * length^-2</code>.</p>"},{"location":"explanation/#number-density-at-sea-level","title":"Number density at sea level","text":"<p>Sea level is defined by \\(z=0\\), hence the number density at sea level of molecule M is simply \\(n_{\\mathrm{M}}(0)\\). Number density at sea level has dimensions of <code>length^-3</code>.</p>"},{"location":"explanation/#mass-density-at-sea-level","title":"Mass density at sea level","text":"<p>Similarly, mass density at sea level is \\(\\rho_{\\mathrm{M}}(0) = m_{\\mathrm{M}} \\, n_{\\mathrm{M}}(0)\\). Mass density at sea level has dimensions of <code>mass * length^-3</code>.</p>"},{"location":"explanation/#dataset-schema","title":"Dataset schema","text":"<p>Joseki produces atmospheric profile datasets in the NetCDF format using the xarray library which provides a comprehensive, robust and convenient interface to read, write, manipulate and visualise NetCDF data.</p>"},{"location":"explanation/#metadata-conventions","title":"Metadata conventions","text":"<p>The NetCDF format allows to store metadata alongside data. Joseki's datasets metadata follow the conventions for Climate and Forecast (v1.10).</p>"},{"location":"explanation/#standard-names","title":"Standard names","text":"<p>The Climate and Forecast (CF) conventions define standard names to describe variables. Joseki's datasets comply with CF Standard Name Table Version 81, 25 April 2023 except for the following variables for which a standard name did not exist (hence we derived one):</p> Standard name Long name Units <code>air_number_density</code> <code>air number density</code> <code>m^-3</code>"},{"location":"explanation/#structure","title":"Structure","text":"<p>A dataset includes 4+ data variables:</p> Standard name Long name Symbol Units <code>air_pressure</code> <code>air pressure</code> <code>p</code> <code>Pa</code> <code>air_temperature</code> <code>air temperature</code> <code>t</code> <code>K</code> <code>air_number_density</code> <code>air number density</code> <code>n</code> <code>m^-3</code> <code>mole_fraction_of_M_in_air</code> <code>mole fraction of M in air</code> <code>x_M</code> <code>dimensionless</code> <p>where <code>M</code> is the chemical formula of the given molecule (e.g.  <code>mole_fraction_of_H2O_in_air</code> is associated the symbol <code>x_H2O</code>), and one of the  two following coordinates variables:</p> Standard name Long name Symbol Units <code>altitude</code> <code>altitude</code> <code>z</code> <code>km</code> <code>layer_center_altitude</code> <code>layer center altitude</code> <code>z</code> <code>km</code> <p>All data variables depend solely on the altitude (either <code>altitude</code> or <code>layer_center_altitude</code>).</p>"},{"location":"how-to-guides/","title":"How-to guides","text":""},{"location":"how-to-guides/#quickstart","title":"Quickstart","text":"<p>The main interface of Joseki is its make  method. This method creates the atmospheric profile corresponding to a given identifier. For example, make the so-called AFGL US Standard atmospheric profile from  Anderson et al (1986) with:</p> <pre><code>import joseki\n\nds = joseki.make(identifier=\"afgl_1986-us_standard\")\n</code></pre> <p>Display the available identifiers with:</p> <pre><code>joseki.identifiers()\n</code></pre> <p>Use the <code>to_netcdf</code> method to save the dataset to the disk as a  netCDF file:</p> <pre><code>ds.to_netcdf(\"my_dataset.nc\")\n</code></pre> <p>For other formats, refer to the  xarray IO documentation.</p> Saving to CSV file <pre><code>ds.to_dataframe().to_csv(\"my_dataset.csv\")\n</code></pre> <p>Note that one drawback of saving to a CSV file in the above manner is that the information on the quantity units is lost.</p> <p>Open the dataset again using  <code>open_dataset</code>:</p> <pre><code>ds = joseki.open_dataset(\"my_dataset.nc\")\n</code></pre> <p>The datasets format is described here.</p>"},{"location":"how-to-guides/#altitude-grid","title":"Altitude grid","text":"<p>You can specify the altitude grid for your atmospheric profile. If the source atmospheric profile is based on tabulated data, it is going to be interpolated on the specified altitude grid.</p> Example <pre><code>ds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    z={\n        \"value\": [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n        \"units\": \"km\",\n    },\n)\n</code></pre> <p>For more information about units specifications, please refer to the  pint documentation.</p> <p>Alternatively, instead of using a list you can also specify the altitude values as a Numpy array:</p> Example <pre><code>import numpy as np\n\nds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    z={\n        \"value\": np.linspace(0, 100, 51),\n        \"units\": \"km\",\n    },\n)\n</code></pre> <p>Or use Joseki's unit registry directly:</p> Example <pre><code>from joseki.units import ureg\n\nimport numpy as np\n\nds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    z=np.linspace(0, 100, 51) * ureg.km,\n)\n</code></pre> <p>During interpolation, the column number densities associated to the different atmospheric constituents are likely going to be changed. In the example above, the ozone column number density is increased to  346.60 Dobson units compared to the atmospheric profile with the original altitude grid, which has an ozone column number density of 345.75 Dobson units. To ensure column densities are conserved during interpolation, set the  <code>conserve_column</code> parameter to <code>True</code>.</p> Example <pre><code>ds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    z=np.linspace(0, 100, 51) * ureg.km,\n    conserve_column=True,\n)\n</code></pre>"},{"location":"how-to-guides/#molecules-selection","title":"Molecules selection","text":"<p>You might be interested only in the mole fraction data of specific molecules. To select the molecules you want to be included in your profile, specify them with the <code>molecules</code> parameter:</p> <pre><code>ds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    molecules=[\"H2O\", \"CO2\", \"O3\"],\n)\n</code></pre> <p>In the above example, the mole fraction data covers the molecules H2O, CO2 and  O3 only.</p>"},{"location":"how-to-guides/#advanced-options","title":"Advanced options","text":"<p>The collection of atmospheric profiles defined by Anderson et al (1986) includes mole fraction data for 28 molecules, where molecules 8-28 are described as additional. By default, these additional molecules are included in the atmospheric profile. To discard these additional molecules, set the <code>additional_molecules</code> parameter to <code>False</code>:</p> <pre><code>ds = joseki.make(\n    identifier=\"afgl_1986-us_standard\",\n    additional_molecules=False,\n)\n</code></pre> <p>The resulting dataset now includes only 7 molecules, instead of 28.</p>"},{"location":"how-to-guides/#derived-quantities","title":"Derived quantities","text":"<p>You can compute various derived quantities from a thermophysical properties dataset produced by <code>joseki</code>, as illustrated by the examples below.</p> Column number density <pre><code>ds = joseki.make(identifier=\"afgl_1986-us_standard\")\nds.joseki.column_number_density[\"O3\"].to(\"dobson_unit\")\n</code></pre> Column mass density <pre><code>ds.joseki.column_mass_density[\"H2O\"]\n</code></pre> Number density at sea level <pre><code>ds.joseki.number_density_at_sea_level[\"CO2\"]\n</code></pre> Mass density at sea level <pre><code>ds.joseki.mass_density_at_sea_level[\"CH4\"]\n</code></pre> <p>For further details on these methods, refer to the API reference.</p>"},{"location":"how-to-guides/#rescaling","title":"Rescaling","text":"<p>You can modify the amount of a given set of molecules in your thermophysical properties dataset by applying a  rescale  transformation.</p> <p>Example</p> <pre><code>ds = joseki.make(identifier=\"afgl_1986-us_standard\")\nrescaled = ds.joseki.rescale(\n   factors={\n      \"H2O\": 0.5,\n      \"CO2\": 1.5,\n      \"CH4\": 1.1,\n   }\n)\n</code></pre> <p>In the example above, the amount of water vapor is halfed whereas the amount of carbon dioxide and methane is increased by 150% and 110%, respectively. When a rescale transformation has been applied to a dataset, its <code>history</code>  attribute is updated to indicate what scaling factors were applied to what  molecules.</p> <p>If you do not know the scaling factors but instead the target amounts that you  want for each molecule, the rescale_to  transformation might be more relevant.</p> <p>Example</p> <pre><code>ds = joseki.make(identifier=\"afgl_1986-us_standard\")\nrescaled = ds.joseki.rescale_to(\n   target={\n      \"H2O\": {\"value\": 25, \"units\": \"kg / m**2\"},\n      \"CO2\": {\"value\": 420, \"units\": \"ppm\"},\n      \"O3\": {\"value\": 280, \"units\": \"dobson_unit\"},\n   }\n)\n</code></pre> <p>In the example above, each molecule is associated a target amount that must be  reached in the rescaled profile. As illustrated in the example, different  quantities\u2014e.g. column mass density, mole fraction at sea level and column  number density\u2014are supported to specify the target amount. The corresponding amount are computed for the initial profile and the scaling factors are given by the ratios of the target and initial amounts.</p>"},{"location":"how-to-guides/#plotting","title":"Plotting","text":"<p>Note</p> <p>For plotting, you will need to install the matplotlib library.</p> <p>You can easily make a plot of any of the variables of a dataset, i.e., air pressure (<code>p</code>), air temperature (<code>t</code>), air number density (<code>n</code>) or mole fraction (<code>x_*</code>):</p> Pressure plot <pre><code>import matplotlib.pyplot as plt \n\nds = joseki.make(\n   identifier=\"afgl_1986-us_standard\",\n   additional_molecules=False\n)\n\nds.p.plot(\n   figsize=(4, 8),\n   ls=\"dotted\",\n   marker=\".\",\n   y=\"z\",\n   xscale=\"log\",\n)\nplt.show()\n</code></pre> <p></p> Temperature plot <pre><code>ds.t.plot(\n   figsize=(4, 8),\n   ls=\"dotted\",\n   marker=\".\",\n   y=\"z\",\n   xscale=\"linear\",\n)\nplt.show()\n</code></pre> <p></p> Number density plot <pre><code>ds.n.plot(\n   figsize=(4, 8),\n   ls=\"dotted\",\n   marker=\".\",\n   y=\"z\",\n   xscale=\"log\",\n)\nplt.show()\n</code></pre> <p></p> Volume fraction plot <pre><code>plt.figure(figsize=(8, 8)) \n\nfor m in ds.joseki.molecules:\n   ds[f\"x_{m}\"].plot(\n      ls=\"dotted\",\n      marker=\".\",\n      y=\"z\",\n      xscale=\"log\",\n   )\n\nplt.xlabel(\"mole fraction [dimensionless]\")\nplt.legend(ds.joseki.molecules)\nplt.show()\n</code></pre> <p></p>"},{"location":"reference/","title":"Reference","text":"<p>This reference manual details functions, modules, and objects included in <code>joseki</code>, describing what they are and what they do.</p>"},{"location":"reference/#joseki.accessor","title":"<code>joseki.accessor</code>","text":"<p>Accessor module.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor","title":"<code>joseki.accessor.JosekiAccessor</code>","text":"<p>Joseki accessor.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>@xr.register_dataset_accessor(\"joseki\")\nclass JosekiAccessor:  # pragma: no cover\n    \"\"\"Joseki accessor.\"\"\"\n\n    def __init__(self, xarray_obj):\n        self._obj = xarray_obj\n\n    @property\n    def molecules(self) -&gt; t.List[str]:\n        \"\"\"Return list of molecules.\"\"\"\n        return [c[2:] for c in self._obj.data_vars if c.startswith(\"x_\")]\n\n    @property\n    def column_number_density(\n        self,\n    ) -&gt; t.Dict[str, pint.Quantity]:\n        r\"\"\"Compute column number density.\n\n        Returns:\n            A mapping of molecule and column number density.\n\n        Notes:\n            The column number density is given by:\n\n            $$\n            N_{\\mathrm{M}} = \\int n_{\\mathrm{M}}(z) \\, \\mathrm{d} z\n            $$\n\n            with\n\n            $$\n            n_{\\mathrm{M}}(z) = x_{\\mathrm{M}}(z) \\, n(z)\n            $$\n\n            where\n\n            * $z$ is the altitude,\n            * $x_{\\mathrm{M}}(z)$ is the mole fraction of molecule M\n            at altitude $z$,\n            * $n(z)$ is the air number density at altitude $z$,\n            * $n_{\\mathrm{M}}(z)$ is the number density of molecule M at\n            altitude $z$.\n\n            The  integration is performed using the trapezoidal rule.\n        \"\"\"\n        ds = self._obj\n\n        logger.debug(\"Computing column number density using the trapezoidal rule.\")\n\n        _column_number_density = {}\n        for m in self.molecules:\n            integral = (ds[f\"x_{m}\"] * ds.n).integrate(\n                coord=\"z\"\n            )  # integrate using the trapezoidal rule\n            units = \" \".join([ds[var].attrs[\"units\"] for var in [f\"x_{m}\", \"n\", \"z\"]])\n            _column_number_density[m] = (\n                integral.values * ureg.Unit(units)\n            ).to_base_units()\n\n        return _column_number_density\n\n    @property\n    def column_mass_density(\n        self,\n    ) -&gt; t.Dict[str, pint.Quantity]:\n        r\"\"\"Compute column mass density.\n\n        Returns:\n            A mapping of molecule and column mass density.\n\n        Notes:\n            The column mass density is given by:\n\n            $$\n            \\sigma_{\\mathrm{M}} = N_{\\mathrm{M}} \\, m_{\\mathrm{M}}\n            $$\n\n            where\n\n            * $N_{\\mathrm{M}}$ is the column number density of molecule M,\n            * $m_{\\mathrm{M}}$ is the molecular mass of molecule M.\n        \"\"\"\n        _column_number_density = self.column_number_density\n        return {\n            m: (molecular_mass(m) * _column_number_density[m]).to(\"kg/m^2\")\n            for m in self.molecules\n        }\n\n    @property\n    def number_density_at_sea_level(\n        self,\n    ) -&gt; t.Dict[str, pint.Quantity]:\n        \"\"\"Compute number density at sea level.\n\n        Returns:\n            A mapping of molecule and number density at sea level.\n        \"\"\"\n        ds = self._obj\n        n = to_quantity(ds.n.isel(z=0))\n        return {m: (to_quantity(ds[f\"x_{m}\"].isel(z=0)) * n) for m in self.molecules}\n\n    @property\n    def mass_density_at_sea_level(\n        self,\n    ) -&gt; t.Dict[str, pint.Quantity]:\n        \"\"\"Compute mass density at sea level.\n\n        Returns:\n            A mapping of molecule and mass density at sea level.\n        \"\"\"\n        _number_density_at_sea_level = self.number_density_at_sea_level\n        return {\n            m: (molecular_mass(m) * _number_density_at_sea_level[m]).to(\"kg/m^3\")\n            for m in self.molecules\n        }\n\n    @property\n    def mole_fraction_at_sea_level(\n        self,\n    ) -&gt; t.Dict[str, pint.Quantity]:\n        \"\"\"Compute mole fraction at sea level.\n\n        Returns:\n            A mapping of molecule and mole fraction at sea level.\n        \"\"\"\n        ds = self._obj\n        return {m: to_quantity(ds[f\"x_{m}\"].isel(z=0)).item() for m in self.molecules}\n\n    @property\n    def mole_fraction(self) -&gt; xr.DataArray:\n        \"\"\"Extract mole fraction and tabulate as a function of (m, z).\n\n        Returns:\n            Mole fraction.\n        \"\"\"\n        ds = self._obj\n        molecules = self.molecules\n        concatenated = xr.concat([ds[f\"x_{m}\"] for m in molecules], dim=\"m\")\n        concatenated[\"m\"] = (\"m\", molecules, {\"long_name\": \"molecule\"})\n        concatenated.attrs.update(\n            {\n                \"standard_name\": \"mole_fraction\",\n                \"long_name\": \"mole fraction\",\n                \"units\": \"dimensionless\",\n            }\n        )\n        concatenated.name = \"x\"\n        return concatenated\n\n    @property\n    def mass_fraction(self) -&gt; xr.DataArray:\n        \"\"\"Extract mass fraction and tabulate as a function of (m, z).\n\n        Returns:\n            Mass fraction.\n        \"\"\"\n        x = self.mole_fraction\n        m_air = self.air_molar_mass\n        m = molar_mass(molecules=self.molecules)\n        y = (x * m / m_air).rename(\"y\")\n        y.attrs.update(\n            {\n                \"standard_name\": \"mass_fraction_in_air\",\n                \"long_name\": \"mass fraction\",\n                \"units\": \"kg * kg^-1\",\n            }\n        )\n        return y\n\n    @property\n    def air_molar_mass(self) -&gt; xr.DataArray:\n        r\"\"\"\n        Compute air molar mass as a function of altitude.\n\n        Returns:\n            Air molar mass.\n\n        Notes:\n            The air molar mass is given by:\n\n            $$\n            M_{\\mathrm{air}} =\n            \\frac{\n                \\sum_{\\mathrm{M}} x_{\\mathrm{M}} \\, m_{\\mathrm{M}}\n            }{\n                \\sum_{\\mathrm{M}} x_{\\mathrm{M}}\n            }\n            $$\n\n            where\n            * $x_{\\mathrm{M}}$ is the mole fraction of molecule M,\n            * $m_{\\mathrm{M}}$ is the molar mass of molecule M.\n\n            To compute the air molar mass accurately, the mole fraction of\n            molecular nitrogen (N2), molecular oxygen (O2), and argon (Ar) are\n            required. If these are not present in the dataset, they are\n            computed using the assumption that the mole fraction of these\n            molecules are constant with altitude and set to the following\n            values:\n\n            * molecular nitrogen (N2): 0.78084\n            * molecular oxygen (O2): 0.209476\n            * argon (Ar): 0.00934\n\n            are independent of altitude.\n\n            Since nothing garantees that the mole fraction sum is equal to\n            one, the air molar mass is computed as the sum of the mole\n            fraction weighted molar mass divided by the sum of the mole\n            fraction.\n        \"\"\"\n        ds = self._obj\n\n        # for molar mass computation to be accurate, main air constituents\n        # must be present in the dataset\n        ds_copy = ds.copy(deep=True)\n        for m in AIR_MAIN_CONSTITUENTS_MOLAR_FRACTION:\n            if f\"x_{m}\" not in ds:\n                value = AIR_MAIN_CONSTITUENTS_MOLAR_FRACTION[m]\n                ds_copy[f\"x_{m}\"] = (\"z\", np.full_like(ds.n, value))\n                ds_copy[f\"x_{m}\"].attrs.update({\"units\": \"dimensionless\"})\n\n        # compute air molar mass\n        x = ds_copy.joseki.mole_fraction\n        molecules = x.m.values\n        mm = xr.DataArray(\n            data=np.array([MM[m] for m in molecules]),\n            coords={\"m\": (\"m\", molecules)},\n            attrs={\"units\": \"dimensionless\"},\n        )\n\n        mm_average = (x * mm).sum(dim=\"m\") / (x.sum(dim=\"m\"))\n\n        mm_average.attrs.update(\n            {\n                \"long_name\": \"air molar mass\",\n                \"units\": \"kg/mol\",\n            }\n        )\n\n        return mm_average\n\n    def scaling_factors(\n        self, target: t.MutableMapping[str, pint.Quantity | dict | xr.DataArray]\n    ) -&gt; t.MutableMapping[str, float]:\n        \"\"\"Compute scaling factor(s) to reach specific target amount(s).\n\n        Args:\n            target: Mapping of molecule and target amount.\n\n        Raises:\n            ValueError: If a target amount has dimensions that are not supported.\n\n        Returns:\n            Mapping of molecule and scaling factors.\n\n        Notes:\n            For each molecule in the ``target`` mapping, the target amount is\n            interpreted, depending on its dimensions (indicated in square\n            brackets), as:\n\n            * a column number density [`length^-2`],\n            * a column mass density [`mass * length^-2`],\n            * a number density at sea level [`length^-3`],\n            * a mass density at sea level [`mass * length^-3`],\n            * a mole fraction at sea level [`dimensionless`]\n\n            The scaling factor is then evaluated as the ratio of the target\n            amount with the original amount, for each molecule.\n\n        See Also:\n            `rescale`\n        \"\"\"\n        compute_initial_amount = {\n            \"[length]^-2\": self.column_number_density,\n            \"[mass] * [length]^-2\": self.column_mass_density,\n            \"[length]^-3\": self.number_density_at_sea_level,\n            \"[mass] * [length]^-3\": self.mass_density_at_sea_level,\n            \"\": self.mole_fraction_at_sea_level,\n        }\n        factors = {}\n        for m, target_amount in target.items():\n            target_amount = to_quantity(target_amount)\n            initial_amount = None\n            for dim in compute_initial_amount.keys():\n                if target_amount.check(dim):\n                    initial_amount = compute_initial_amount[dim][m]\n            if initial_amount is None:\n                raise ValueError\n            factors[m] = _scaling_factor(\n                initial_amount=initial_amount, target_amount=target_amount\n            )\n        return factors\n\n    def rescale(\n        self, factors: t.MutableMapping[str, float], check_x_sum: bool = False\n    ) -&gt; xr.Dataset:\n        \"\"\"Rescale molecules concentration in atmospheric profile.\n\n        Args:\n            factors: A mapping of molecule and scaling factor.\n            check_x_sum: if True, check that mole fraction sums\n                are never larger than one.\n        Raises:\n            ValueError: if `check_x_sum` is `True` and the\n                dataset is not valid.\n\n        Returns:\n            Rescaled dataset (new object).\n        \"\"\"\n        ds = self._obj\n\n        # update mole fraction\n        x_new = {}\n        for m in factors:\n            with xr.set_options(keep_attrs=True):\n                x_new[f\"x_{m}\"] = ds[f\"x_{m}\"] * factors[m]\n\n        ds = ds.assign(x_new)\n\n        # validate rescaled dataset\n        try:\n            ds.joseki.validate(check_x_sum=check_x_sum)\n        except ValueError as e:\n            raise ValueError(\"Cannot rescale\") from e\n\n        # update history attribute\n        now = datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n        for m in factors.keys():\n            ds.attrs[\"history\"] += (\n                f\"\\n{now} - rescaled {m}'s mole fraction using a scaling \"\n                f\"factor of {factors[m]:.3f} - joseki, version {__version__}\"\n            )\n\n        return ds\n\n    def rescale_to(\n        self,\n        target: t.Mapping[str, pint.Quantity | dict | xr.DataArray],\n        check_x_sum: bool = False,\n    ) -&gt; xr.Dataset:\n        \"\"\"\n        Rescale mole fractions to match target molecular total column\n        densities.\n\n        Args:\n            target: Mapping of molecule and target total column density.\n                Total column must be either a column number density\n                [`length^-2`], a column mass density [`mass * length^-2`], a\n                number density at sea level [`length^-3`], a mass density at\n                sea level [`mass * length^-3`], a mole fraction at\n                sea level [`dimensionless`].\n            check_x_sum: if True, check that mole fraction sums are never\n                larger than one.\n\n        Returns:\n            Rescaled dataset (new object).\n        \"\"\"\n        return self.rescale(\n            factors=self.scaling_factors(target=target),\n            check_x_sum=check_x_sum,\n        )\n\n    def drop_molecules(\n        self,\n        molecules: t.List[str],\n    ) -&gt; xr.Dataset:\n        \"\"\"Drop molecules from dataset.\n\n        Args:\n            molecules: List of molecules to drop.\n\n        Returns:\n            Dataset with molecules dropped.\n        \"\"\"\n        ds = self._obj\n\n        # update history attribute\n        now = datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n\n        ds.attrs[\"history\"] += (\n            f\"\\n{now} - dropped mole fraction data for molecules \"\n            f\"{', '.join(molecules)} - joseki, version {__version__}\"\n        )\n\n        return ds.drop_vars([f\"x_{m}\" for m in molecules])\n\n    def validate(\n        self,\n        check_x_sum: bool = False,\n        ret_true_if_valid: bool = False,\n    ) -&gt; bool:\n        \"\"\"Validate atmosphere thermophysical profile dataset schema.\n\n        Returns:\n            `True` if the dataset complies with the schema, else `False`.\n        \"\"\"\n        return schema.validate(\n            ds=self._obj,\n            check_x_sum=check_x_sum,\n            ret_true_if_valid=ret_true_if_valid,\n        )\n\n    @property\n    def is_valid(self):\n        \"\"\"\n        Return `True` if the dataset complies with the schema, else `False`.\n        \"\"\"\n        try:\n            self.validate(ret_true_if_valid=True)\n            return True\n        except ValueError:\n            return False\n</code></pre>"},{"location":"reference/#joseki.accessor.JosekiAccessor.air_molar_mass","title":"<code>joseki.accessor.JosekiAccessor.air_molar_mass: xr.DataArray</code>  <code>property</code>","text":"<p>Compute air molar mass as a function of altitude.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>Air molar mass.</p> Notes <p>The air molar mass is given by:</p> \\[ M_{\\mathrm{air}} = \\frac{     \\sum_{\\mathrm{M}} x_{\\mathrm{M}} \\, m_{\\mathrm{M}} }{     \\sum_{\\mathrm{M}} x_{\\mathrm{M}} } \\] <p>where * \\(x_{\\mathrm{M}}\\) is the mole fraction of molecule M, * \\(m_{\\mathrm{M}}\\) is the molar mass of molecule M.</p> <p>To compute the air molar mass accurately, the mole fraction of molecular nitrogen (N2), molecular oxygen (O2), and argon (Ar) are required. If these are not present in the dataset, they are computed using the assumption that the mole fraction of these molecules are constant with altitude and set to the following values:</p> <ul> <li>molecular nitrogen (N2): 0.78084</li> <li>molecular oxygen (O2): 0.209476</li> <li>argon (Ar): 0.00934</li> </ul> <p>are independent of altitude.</p> <p>Since nothing garantees that the mole fraction sum is equal to one, the air molar mass is computed as the sum of the mole fraction weighted molar mass divided by the sum of the mole fraction.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.column_mass_density","title":"<code>joseki.accessor.JosekiAccessor.column_mass_density: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute column mass density.</p> <p>Returns:</p> Type Description <code>Dict[str, Quantity]</code> <p>A mapping of molecule and column mass density.</p> Notes <p>The column mass density is given by:</p> \\[ \\sigma_{\\mathrm{M}} = N_{\\mathrm{M}} \\, m_{\\mathrm{M}} \\] <p>where</p> <ul> <li>\\(N_{\\mathrm{M}}\\) is the column number density of molecule M,</li> <li>\\(m_{\\mathrm{M}}\\) is the molecular mass of molecule M.</li> </ul>"},{"location":"reference/#joseki.accessor.JosekiAccessor.column_number_density","title":"<code>joseki.accessor.JosekiAccessor.column_number_density: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute column number density.</p> <p>Returns:</p> Type Description <code>Dict[str, Quantity]</code> <p>A mapping of molecule and column number density.</p> Notes <p>The column number density is given by:</p> \\[ N_{\\mathrm{M}} = \\int n_{\\mathrm{M}}(z) \\, \\mathrm{d} z \\] <p>with</p> \\[ n_{\\mathrm{M}}(z) = x_{\\mathrm{M}}(z) \\, n(z) \\] <p>where</p> <ul> <li>\\(z\\) is the altitude,</li> <li>\\(x_{\\mathrm{M}}(z)\\) is the mole fraction of molecule M at altitude \\(z\\),</li> <li>\\(n(z)\\) is the air number density at altitude \\(z\\),</li> <li>\\(n_{\\mathrm{M}}(z)\\) is the number density of molecule M at altitude \\(z\\).</li> </ul> <p>The  integration is performed using the trapezoidal rule.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.is_valid","title":"<code>joseki.accessor.JosekiAccessor.is_valid</code>  <code>property</code>","text":"<p>Return <code>True</code> if the dataset complies with the schema, else <code>False</code>.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.mass_density_at_sea_level","title":"<code>joseki.accessor.JosekiAccessor.mass_density_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute mass density at sea level.</p> <p>Returns:</p> Type Description <code>Dict[str, Quantity]</code> <p>A mapping of molecule and mass density at sea level.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.mass_fraction","title":"<code>joseki.accessor.JosekiAccessor.mass_fraction: xr.DataArray</code>  <code>property</code>","text":"<p>Extract mass fraction and tabulate as a function of (m, z).</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>Mass fraction.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.mole_fraction","title":"<code>joseki.accessor.JosekiAccessor.mole_fraction: xr.DataArray</code>  <code>property</code>","text":"<p>Extract mole fraction and tabulate as a function of (m, z).</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>Mole fraction.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.mole_fraction_at_sea_level","title":"<code>joseki.accessor.JosekiAccessor.mole_fraction_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute mole fraction at sea level.</p> <p>Returns:</p> Type Description <code>Dict[str, Quantity]</code> <p>A mapping of molecule and mole fraction at sea level.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.molecules","title":"<code>joseki.accessor.JosekiAccessor.molecules: t.List[str]</code>  <code>property</code>","text":"<p>Return list of molecules.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.number_density_at_sea_level","title":"<code>joseki.accessor.JosekiAccessor.number_density_at_sea_level: t.Dict[str, pint.Quantity]</code>  <code>property</code>","text":"<p>Compute number density at sea level.</p> <p>Returns:</p> Type Description <code>Dict[str, Quantity]</code> <p>A mapping of molecule and number density at sea level.</p>"},{"location":"reference/#joseki.accessor.JosekiAccessor.drop_molecules","title":"<code>joseki.accessor.JosekiAccessor.drop_molecules(molecules)</code>","text":"<p>Drop molecules from dataset.</p> <p>Parameters:</p> Name Type Description Default <code>molecules</code> <code>List[str]</code> <p>List of molecules to drop.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with molecules dropped.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def drop_molecules(\n    self,\n    molecules: t.List[str],\n) -&gt; xr.Dataset:\n    \"\"\"Drop molecules from dataset.\n\n    Args:\n        molecules: List of molecules to drop.\n\n    Returns:\n        Dataset with molecules dropped.\n    \"\"\"\n    ds = self._obj\n\n    # update history attribute\n    now = datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n\n    ds.attrs[\"history\"] += (\n        f\"\\n{now} - dropped mole fraction data for molecules \"\n        f\"{', '.join(molecules)} - joseki, version {__version__}\"\n    )\n\n    return ds.drop_vars([f\"x_{m}\" for m in molecules])\n</code></pre>"},{"location":"reference/#joseki.accessor.JosekiAccessor.rescale","title":"<code>joseki.accessor.JosekiAccessor.rescale(factors, check_x_sum=False)</code>","text":"<p>Rescale molecules concentration in atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>factors</code> <code>MutableMapping[str, float]</code> <p>A mapping of molecule and scaling factor.</p> required <code>check_x_sum</code> <code>bool</code> <p>if True, check that mole fraction sums are never larger than one.</p> <code>False</code> <p>Raises:     ValueError: if <code>check_x_sum</code> is <code>True</code> and the         dataset is not valid.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>Rescaled dataset (new object).</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def rescale(\n    self, factors: t.MutableMapping[str, float], check_x_sum: bool = False\n) -&gt; xr.Dataset:\n    \"\"\"Rescale molecules concentration in atmospheric profile.\n\n    Args:\n        factors: A mapping of molecule and scaling factor.\n        check_x_sum: if True, check that mole fraction sums\n            are never larger than one.\n    Raises:\n        ValueError: if `check_x_sum` is `True` and the\n            dataset is not valid.\n\n    Returns:\n        Rescaled dataset (new object).\n    \"\"\"\n    ds = self._obj\n\n    # update mole fraction\n    x_new = {}\n    for m in factors:\n        with xr.set_options(keep_attrs=True):\n            x_new[f\"x_{m}\"] = ds[f\"x_{m}\"] * factors[m]\n\n    ds = ds.assign(x_new)\n\n    # validate rescaled dataset\n    try:\n        ds.joseki.validate(check_x_sum=check_x_sum)\n    except ValueError as e:\n        raise ValueError(\"Cannot rescale\") from e\n\n    # update history attribute\n    now = datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n    for m in factors.keys():\n        ds.attrs[\"history\"] += (\n            f\"\\n{now} - rescaled {m}'s mole fraction using a scaling \"\n            f\"factor of {factors[m]:.3f} - joseki, version {__version__}\"\n        )\n\n    return ds\n</code></pre>"},{"location":"reference/#joseki.accessor.JosekiAccessor.rescale_to","title":"<code>joseki.accessor.JosekiAccessor.rescale_to(target, check_x_sum=False)</code>","text":"<p>Rescale mole fractions to match target molecular total column densities.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Mapping[str, Quantity | dict | DataArray]</code> <p>Mapping of molecule and target total column density. Total column must be either a column number density [<code>length^-2</code>], a column mass density [<code>mass * length^-2</code>], a number density at sea level [<code>length^-3</code>], a mass density at sea level [<code>mass * length^-3</code>], a mole fraction at sea level [<code>dimensionless</code>].</p> required <code>check_x_sum</code> <code>bool</code> <p>if True, check that mole fraction sums are never larger than one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Rescaled dataset (new object).</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def rescale_to(\n    self,\n    target: t.Mapping[str, pint.Quantity | dict | xr.DataArray],\n    check_x_sum: bool = False,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Rescale mole fractions to match target molecular total column\n    densities.\n\n    Args:\n        target: Mapping of molecule and target total column density.\n            Total column must be either a column number density\n            [`length^-2`], a column mass density [`mass * length^-2`], a\n            number density at sea level [`length^-3`], a mass density at\n            sea level [`mass * length^-3`], a mole fraction at\n            sea level [`dimensionless`].\n        check_x_sum: if True, check that mole fraction sums are never\n            larger than one.\n\n    Returns:\n        Rescaled dataset (new object).\n    \"\"\"\n    return self.rescale(\n        factors=self.scaling_factors(target=target),\n        check_x_sum=check_x_sum,\n    )\n</code></pre>"},{"location":"reference/#joseki.accessor.JosekiAccessor.scaling_factors","title":"<code>joseki.accessor.JosekiAccessor.scaling_factors(target)</code>","text":"<p>Compute scaling factor(s) to reach specific target amount(s).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>MutableMapping[str, Quantity | dict | DataArray]</code> <p>Mapping of molecule and target amount.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a target amount has dimensions that are not supported.</p> <p>Returns:</p> Type Description <code>MutableMapping[str, float]</code> <p>Mapping of molecule and scaling factors.</p> Notes <p>For each molecule in the <code>target</code> mapping, the target amount is interpreted, depending on its dimensions (indicated in square brackets), as:</p> <ul> <li>a column number density [<code>length^-2</code>],</li> <li>a column mass density [<code>mass * length^-2</code>],</li> <li>a number density at sea level [<code>length^-3</code>],</li> <li>a mass density at sea level [<code>mass * length^-3</code>],</li> <li>a mole fraction at sea level [<code>dimensionless</code>]</li> </ul> <p>The scaling factor is then evaluated as the ratio of the target amount with the original amount, for each molecule.</p> See Also <p><code>rescale</code></p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def scaling_factors(\n    self, target: t.MutableMapping[str, pint.Quantity | dict | xr.DataArray]\n) -&gt; t.MutableMapping[str, float]:\n    \"\"\"Compute scaling factor(s) to reach specific target amount(s).\n\n    Args:\n        target: Mapping of molecule and target amount.\n\n    Raises:\n        ValueError: If a target amount has dimensions that are not supported.\n\n    Returns:\n        Mapping of molecule and scaling factors.\n\n    Notes:\n        For each molecule in the ``target`` mapping, the target amount is\n        interpreted, depending on its dimensions (indicated in square\n        brackets), as:\n\n        * a column number density [`length^-2`],\n        * a column mass density [`mass * length^-2`],\n        * a number density at sea level [`length^-3`],\n        * a mass density at sea level [`mass * length^-3`],\n        * a mole fraction at sea level [`dimensionless`]\n\n        The scaling factor is then evaluated as the ratio of the target\n        amount with the original amount, for each molecule.\n\n    See Also:\n        `rescale`\n    \"\"\"\n    compute_initial_amount = {\n        \"[length]^-2\": self.column_number_density,\n        \"[mass] * [length]^-2\": self.column_mass_density,\n        \"[length]^-3\": self.number_density_at_sea_level,\n        \"[mass] * [length]^-3\": self.mass_density_at_sea_level,\n        \"\": self.mole_fraction_at_sea_level,\n    }\n    factors = {}\n    for m, target_amount in target.items():\n        target_amount = to_quantity(target_amount)\n        initial_amount = None\n        for dim in compute_initial_amount.keys():\n            if target_amount.check(dim):\n                initial_amount = compute_initial_amount[dim][m]\n        if initial_amount is None:\n            raise ValueError\n        factors[m] = _scaling_factor(\n            initial_amount=initial_amount, target_amount=target_amount\n        )\n    return factors\n</code></pre>"},{"location":"reference/#joseki.accessor.JosekiAccessor.validate","title":"<code>joseki.accessor.JosekiAccessor.validate(check_x_sum=False, ret_true_if_valid=False)</code>","text":"<p>Validate atmosphere thermophysical profile dataset schema.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the dataset complies with the schema, else <code>False</code>.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def validate(\n    self,\n    check_x_sum: bool = False,\n    ret_true_if_valid: bool = False,\n) -&gt; bool:\n    \"\"\"Validate atmosphere thermophysical profile dataset schema.\n\n    Returns:\n        `True` if the dataset complies with the schema, else `False`.\n    \"\"\"\n    return schema.validate(\n        ds=self._obj,\n        check_x_sum=check_x_sum,\n        ret_true_if_valid=ret_true_if_valid,\n    )\n</code></pre>"},{"location":"reference/#joseki.accessor.molecular_mass","title":"<code>joseki.accessor.molecular_mass(m)</code>","text":"<p>Return the average molecular mass of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>str</code> <p>Molecule formula.</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>Average molecular mass.</p> Source code in <code>src/joseki/accessor.py</code> <pre><code>def molecular_mass(m: str) -&gt; pint.Quantity:\n    \"\"\"Return the average molecular mass of a molecule.\n\n    Args:\n        m: Molecule formula.\n\n    Returns:\n        Average molecular mass.\n    \"\"\"\n    return MM[m] * ureg(\"dalton\")\n</code></pre>"},{"location":"reference/#joseki.data","title":"<code>joseki.data</code>","text":"<p>Raw data files.</p>"},{"location":"reference/#joseki.profiles.factory","title":"<code>joseki.profiles.factory</code>","text":"<p>Profile factory module.</p>"},{"location":"reference/#joseki.profiles.factory.ProfileFactory","title":"<code>joseki.profiles.factory.ProfileFactory</code>","text":"<p>Profile factory class.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>@define\nclass ProfileFactory:\n    \"\"\"\n    Profile factory class.\n    \"\"\"\n\n    \"\"\"Profile registry.\"\"\"\n    registry: t.Dict[str, Profile] = field(factory=dict)\n\n    @property\n    def registered_identifiers(self) -&gt; t.List[str]:\n        \"\"\"\n        Registered profile identifiers.\n\n        Returns:\n            List of registered profile identifiers.\n        \"\"\"\n        return list(self.registry.keys())\n\n    def register(\n        self,\n        identifier: str,\n    ) -&gt; t.Callable:\n        \"\"\"\n        Register a profile class.\n\n        Args:\n            identifier: Profile identifier.\n\n        Returns:\n            Decorator function.\n        \"\"\"\n\n        def inner_wrapper(wrapped_class: Profile) -&gt; t.Callable:\n            logger.info(\"Registering profile %s\", identifier)\n            if identifier in self.registry:\n                logger.warning(  # pragma: no cover\n                    \"Profile %s already exists. Will replace it\",\n                    identifier,\n                )\n            self.registry[identifier] = wrapped_class\n            return wrapped_class\n\n        return inner_wrapper\n\n    def create(self, identifier: str, **kwargs) -&gt; Profile:\n        \"\"\"\n        Create a profile instance.\n\n        Args:\n            identifier: Profile identifier.\n\n        Returns:\n            Profile instance.\n        \"\"\"\n        if identifier not in self.registry:\n            logger.fatal(\"Profile %s does not exist in the registry\", identifier)\n            raise ValueError(f\"Profile {identifier} does not exist in the registry\")\n\n        logger.debug(\"Creating profile %s\", identifier)\n        profile_cls = self.registry[identifier]\n        profile = profile_cls(**kwargs)\n        return profile\n</code></pre>"},{"location":"reference/#joseki.profiles.factory.ProfileFactory.registered_identifiers","title":"<code>joseki.profiles.factory.ProfileFactory.registered_identifiers: t.List[str]</code>  <code>property</code>","text":"<p>Registered profile identifiers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of registered profile identifiers.</p>"},{"location":"reference/#joseki.profiles.factory.ProfileFactory.create","title":"<code>joseki.profiles.factory.ProfileFactory.create(identifier, **kwargs)</code>","text":"<p>Create a profile instance.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <p>Returns:</p> Type Description <code>Profile</code> <p>Profile instance.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>def create(self, identifier: str, **kwargs) -&gt; Profile:\n    \"\"\"\n    Create a profile instance.\n\n    Args:\n        identifier: Profile identifier.\n\n    Returns:\n        Profile instance.\n    \"\"\"\n    if identifier not in self.registry:\n        logger.fatal(\"Profile %s does not exist in the registry\", identifier)\n        raise ValueError(f\"Profile {identifier} does not exist in the registry\")\n\n    logger.debug(\"Creating profile %s\", identifier)\n    profile_cls = self.registry[identifier]\n    profile = profile_cls(**kwargs)\n    return profile\n</code></pre>"},{"location":"reference/#joseki.profiles.factory.ProfileFactory.register","title":"<code>joseki.profiles.factory.ProfileFactory.register(identifier)</code>","text":"<p>Register a profile class.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function.</p> Source code in <code>src/joseki/profiles/factory.py</code> <pre><code>def register(\n    self,\n    identifier: str,\n) -&gt; t.Callable:\n    \"\"\"\n    Register a profile class.\n\n    Args:\n        identifier: Profile identifier.\n\n    Returns:\n        Decorator function.\n    \"\"\"\n\n    def inner_wrapper(wrapped_class: Profile) -&gt; t.Callable:\n        logger.info(\"Registering profile %s\", identifier)\n        if identifier in self.registry:\n            logger.warning(  # pragma: no cover\n                \"Profile %s already exists. Will replace it\",\n                identifier,\n            )\n        self.registry[identifier] = wrapped_class\n        return wrapped_class\n\n    return inner_wrapper\n</code></pre>"},{"location":"reference/#joseki.profiles.core","title":"<code>joseki.profiles.core</code>","text":"<p>Core module for atmosphere thermophysical profiles.</p> <p>The <code>Profile</code> abstract class defines the interface for atmosphere thermophysical profiles. The <code>interp</code> function is used to interpolate an atmosphere thermophysical profile on new altitude values.</p>"},{"location":"reference/#joseki.profiles.core.Profile","title":"<code>joseki.profiles.core.Profile</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class for atmosphere thermophysical profiles.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>@define\nclass Profile(ABC):\n    \"\"\"\n    Abstract class for atmosphere thermophysical profiles.\n    \"\"\"\n\n    @abstractmethod\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        \"\"\"\n        Return the profile as a dataset.\n\n        Args:\n            z: Altitude grid.\n                If the profile can be evaluated at arbitrary altitudes, this\n                parameter is passed to the evaluating method for that profile.\n                If the profile is defined on a fixed altitude grid, this parameter\n                is used to interpolate the profile on the specified altitude grid.\n            interp_method: Interpolation method for each variable.\n                If ``None``, the default interpolation method is used.\n                Interpolation may be required if the profile is defined on a fixed\n                altitude grid, and the altitude grid is not the same as the one\n                used to define the profile.\n                Interpolation may also not be required, e.g. if the profile is\n                defined by analytical function(s) of the altitude variable.\n            conserve_column: If `True`, ensure that column densities are conserved\n                during interpolation.\n            kwargs: Parameters passed to lower-level methods.\n\n        Returns:\n            Atmospheric profile.\n        \"\"\"\n        pass  # pragma: no cover\n</code></pre>"},{"location":"reference/#joseki.profiles.core.Profile.to_dataset","title":"<code>joseki.profiles.core.Profile.to_dataset(z=None, interp_method=None, conserve_column=False, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Return the profile as a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Optional[Quantity]</code> <p>Altitude grid. If the profile can be evaluated at arbitrary altitudes, this parameter is passed to the evaluating method for that profile. If the profile is defined on a fixed altitude grid, this parameter is used to interpolate the profile on the specified altitude grid.</p> <code>None</code> <code>interp_method</code> <code>Optional[Mapping[str, str]]</code> <p>Interpolation method for each variable. If <code>None</code>, the default interpolation method is used. Interpolation may be required if the profile is defined on a fixed altitude grid, and the altitude grid is not the same as the one used to define the profile. Interpolation may also not be required, e.g. if the profile is defined by analytical function(s) of the altitude variable.</p> <code>None</code> <code>conserve_column</code> <code>bool</code> <p>If <code>True</code>, ensure that column densities are conserved during interpolation.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Parameters passed to lower-level methods.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>@abstractmethod\ndef to_dataset(\n    self,\n    z: t.Optional[pint.Quantity] = None,\n    interp_method: t.Optional[t.Mapping[str, str]] = None,\n    conserve_column: bool = False,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Return the profile as a dataset.\n\n    Args:\n        z: Altitude grid.\n            If the profile can be evaluated at arbitrary altitudes, this\n            parameter is passed to the evaluating method for that profile.\n            If the profile is defined on a fixed altitude grid, this parameter\n            is used to interpolate the profile on the specified altitude grid.\n        interp_method: Interpolation method for each variable.\n            If ``None``, the default interpolation method is used.\n            Interpolation may be required if the profile is defined on a fixed\n            altitude grid, and the altitude grid is not the same as the one\n            used to define the profile.\n            Interpolation may also not be required, e.g. if the profile is\n            defined by analytical function(s) of the altitude variable.\n        conserve_column: If `True`, ensure that column densities are conserved\n            during interpolation.\n        kwargs: Parameters passed to lower-level methods.\n\n    Returns:\n        Atmospheric profile.\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"reference/#joseki.profiles.core.extrapolate","title":"<code>joseki.profiles.core.extrapolate(ds, z_extra, direction, method=DEFAULT_METHOD, conserve_column=False)</code>","text":"<p>Extrapolate an atmospheric profile to new altitude(s).</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Initial atmospheric profile.</p> required <code>z_extra</code> <code>Quantity</code> <p>Altitude(s) to extrapolate to.</p> required <code>direction</code> <code>str</code> <p>Direction of the extrapolation, either \"up\" or \"down\".</p> required <code>method</code> <code>Dict[str, str]</code> <p>Mapping of variable and interpolation method. If a variable is not in the mapping, the linear interpolation is used. By default, linear interpolation is used for all variables.</p> <code>DEFAULT_METHOD</code> <code>conserve_column</code> <code>bool</code> <p>If True, ensure that column densities are conserved.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the extrapolation direction is not \"up\" or \"down\".</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>Extrapolated atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def extrapolate(\n    ds: xr.Dataset,\n    z_extra: pint.Quantity,\n    direction: str,\n    method: t.Dict[str, str] = DEFAULT_METHOD,\n    conserve_column: bool = False,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Extrapolate an atmospheric profile to new altitude(s).\n\n    Args:\n        ds: Initial atmospheric profile.\n        z_extra: Altitude(s) to extrapolate to.\n        direction: Direction of the extrapolation, either \"up\" or \"down\".\n        method: Mapping of variable and interpolation method.\n            If a variable is not in the mapping, the linear interpolation is used.\n            By default, linear interpolation is used for all variables.\n        conserve_column: If True, ensure that column densities are conserved.\n\n    Raises:\n        ValueError: If the extrapolation direction is not \"up\" or \"down\".\n\n    Returns:\n        Extrapolated atmospheric profile.\n    \"\"\"\n    if direction not in [\"up\", \"down\"]:\n        msg = (\n            f\"Extrapolation direction must be either 'up' or 'down', got \"\n            f\"{direction}.\"\n        )\n        logger.critical(msg)\n        raise ValueError(msg)\n\n    z = to_quantity(ds.z)\n\n    if direction == \"down\" and np.any(z_extra &gt;= z.min()):\n        msg = (\n            f\"Cannot extrapolate down to {z_extra:~P}, \"\n            f\"minimum altitude is {z.min():~P}.\"\n        )\n        logger.critical(msg)\n        raise ValueError(msg)\n\n    elif direction == \"up\" and np.any(z_extra &lt;= z.max()):\n        msg = (\n            f\"Cannot extrapolate up to {z_extra:~P}, \"\n            f\"maximum altitude is {z.max():~P}.\"\n        )\n        logger.critical(msg)\n        raise ValueError(msg)\n\n    else:\n        extrapolated = interp(\n            ds=ds,\n            z_new=np.concatenate([np.atleast_1d(z_extra), z]),\n            method=method,\n            conserve_column=conserve_column,\n            fill_value=\"extrapolate\",\n        )\n        extrapolated.attrs.update(\n            history=extrapolated.history + f\"\\n{utcnow()} \"\n            f\"- extrapolate - joseki, version {__version__}\"\n        )\n        return extrapolated\n</code></pre>"},{"location":"reference/#joseki.profiles.core.interp","title":"<code>joseki.profiles.core.interp(ds, z_new, method=DEFAULT_METHOD, conserve_column=False, **kwargs)</code>","text":"<p>Interpolate atmospheric profile on new altitudes.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Atmospheric profile to interpolate.</p> required <code>z_new</code> <code>Quantity</code> <p>Altitudes values at which to interpolate the atmospheric profile.</p> required <code>method</code> <code>Dict[str, str]</code> <p>Mapping of variable and interpolation method. If a variable is not in the mapping, the linear interpolation is used. By default, linear interpolation is used for all variables.</p> <code>DEFAULT_METHOD</code> <code>conserve_column</code> <code>bool</code> <p>If True, ensure that column densities are conserved.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Parameters passed to <code>scipy.interpolate.interp1d</code> (except 'kind' and 'bounds_error').</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Interpolated atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def interp(\n    ds: xr.Dataset,\n    z_new: pint.Quantity,\n    method: t.Dict[str, str] = DEFAULT_METHOD,\n    conserve_column: bool = False,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"Interpolate atmospheric profile on new altitudes.\n\n    Args:\n        ds: Atmospheric profile to interpolate.\n        z_new: Altitudes values at which to interpolate the atmospheric profile.\n        method: Mapping of variable and interpolation method.\n            If a variable is not in the mapping, the linear interpolation is used.\n            By default, linear interpolation is used for all variables.\n        conserve_column: If True, ensure that column densities are conserved.\n        kwargs: Parameters passed to `scipy.interpolate.interp1d` (except\n            'kind' and 'bounds_error').\n\n    Returns:\n        Interpolated atmospheric profile.\n    \"\"\"\n    # sort altitude values\n    z_new = np.sort(z_new)\n\n    z_units = ds.z.attrs[\"units\"]\n    z_new_values = z_new.m_as(z_units)\n\n    coords = {\"z\": z_new.to(z_units)}\n\n    # kwargs cannot contain 'kind' and 'bounds_error'\n    kwargs.pop(\"kind\", None)\n    kwargs.pop(\"bounds_error\", None)\n\n    try:\n        if kwargs[\"fill_value\"] == \"extrapolate\":  # pragma: no cover\n            bounds_error = None\n    except KeyError:\n        bounds_error = True\n\n    # Interpolate pressure, temperature and density\n    data_vars = {}\n    for var in [\"p\", \"t\", \"n\"]:\n        f = interpolate.interp1d(\n            x=ds.z.values,\n            y=ds[var].values,\n            kind=method.get(var, method[\"default\"]),\n            bounds_error=bounds_error,\n            **kwargs,\n        )\n        data_vars[var] = ureg.Quantity(f(z_new_values), ds[var].attrs[\"units\"])\n\n    # Interpolate mole fraction\n    for m in ds.joseki.molecules:\n        var = f\"x_{m}\"\n        f = interpolate.interp1d(\n            x=ds.z.values,\n            y=ds[var].values,\n            kind=method.get(var, method[\"default\"]),\n            bounds_error=bounds_error,\n            **kwargs,\n        )\n        data_vars[var] = ureg.Quantity(f(z_new_values), ds[var].attrs[\"units\"])\n\n    # Attributes\n    attrs = ds.attrs\n    author = f\"joseki, version {__version__}\"\n    attrs.update(\n        {\n            \"history\": f\"{utcnow()} - dataset interpolation by {author}.\",\n        }\n    )\n\n    # Convert to dataset\n    logger.debug(\"convert interpolated data to dataset\")\n    interpolated = schema.convert(\n        data_vars=data_vars,\n        coords=coords,\n        attrs=attrs,\n    )\n\n    # Compute scaling factors to conserve column densities\n    if conserve_column:\n        return rescale_to_column(reference=ds, ds=interpolated)\n\n    return interpolated\n</code></pre>"},{"location":"reference/#joseki.profiles.core.regularize","title":"<code>joseki.profiles.core.regularize(ds, method=DEFAULT_METHOD, conserve_column=False, options=DEFAULT_OPTIONS, **kwargs)</code>","text":"<p>Regularize the profile's altitude grid.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Initial atmospheric profile.</p> required <code>method</code> <code>Dict[str, str]</code> <p>Mapping of variable and interpolation method. If a variable is not in the mapping, the linear interpolation is used. By default, linear interpolation is used for all variables.</p> <code>DEFAULT_METHOD</code> <code>conserve_column</code> <code>bool</code> <p>If True, ensure that column densities are conserved.</p> <code>False</code> <code>options</code> <code>Dict[str, Union[int, str, Quantity]]</code> <p>Options for the regularization. Mapping with possible keys:     - \"num\": Number of points in the new altitude grid.     - \"zstep\": Altitude step in the new altitude grid.         If \"auto\", the minimum altitude step is used.</p> <code>DEFAULT_OPTIONS</code> <code>kwargs</code> <code>Any</code> <p>Keyword arguments passed to the interpolation function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Regularized atmospheric profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def regularize(\n    ds: xr.Dataset,\n    method: t.Dict[str, str] = DEFAULT_METHOD,\n    conserve_column: bool = False,\n    options: t.Dict[str, t.Union[int, str, pint.Quantity]] = DEFAULT_OPTIONS,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"Regularize the profile's altitude grid.\n\n    Args:\n        ds: Initial atmospheric profile.\n        method: Mapping of variable and interpolation method.\n            If a variable is not in the mapping, the linear interpolation is used.\n            By default, linear interpolation is used for all variables.\n        conserve_column: If True, ensure that column densities are conserved.\n        options: Options for the regularization.\n            Mapping with possible keys:\n                - \"num\": Number of points in the new altitude grid.\n                - \"zstep\": Altitude step in the new altitude grid.\n                    If \"auto\", the minimum altitude step is used.\n        kwargs: Keyword arguments passed to the interpolation function.\n\n    Returns:\n        Regularized atmospheric profile.\n    \"\"\"\n    z = to_quantity(ds.z)\n    if options.get(\"num\", None):\n        z_new = np.linspace(\n            z.min(),\n            z.max(),\n            options[\"num\"],\n        )\n    elif options.get(\"zstep\", None):\n        zstep = options[\"zstep\"]\n        zunits = z.units\n        if isinstance(zstep, ureg.Quantity):\n            pass\n        elif isinstance(zstep, str):\n            if zstep == \"auto\":\n                zstep = np.diff(z).min()\n            else:\n                raise ValueError(f\"Invalid zstep value: {zstep}\")\n        else:\n            raise ValueError(f\"Invalid zstep value: {zstep}\")\n        z_new = (\n            np.arange(\n                z.min().m_as(zunits),\n                z.max().m_as(zunits),\n                zstep.m_as(zunits),\n            )\n            * zunits\n        )\n\n    else:\n        raise ValueError(\"options must contain either 'num' or 'zstep' key.\")\n\n    return interp(\n        ds=ds,\n        z_new=z_new,\n        method=method,\n        conserve_column=conserve_column,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/#joseki.profiles.core.rescale_to_column","title":"<code>joseki.profiles.core.rescale_to_column(reference, ds)</code>","text":"<p>Rescale mole fraction to ensure that column densities are conserved.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Dataset</code> <p>Reference profile.</p> required <code>ds</code> <code>Dataset</code> <p>Profile to rescale.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Rescaled profile.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def rescale_to_column(reference: xr.Dataset, ds: xr.Dataset) -&gt; xr.Dataset:\n    \"\"\"Rescale mole fraction to ensure that column densities are conserved.\n\n    Args:\n        reference: Reference profile.\n        ds: Profile to rescale.\n\n    Returns:\n        Rescaled profile.\n    \"\"\"\n    desired = reference.joseki.column_number_density\n    actual = ds.joseki.column_number_density\n    factors = {}\n    for m in reference.joseki.molecules:\n        if desired[m].m == 0.0:\n            factors[m] = 0.0\n        elif actual[m].m == 0.0:\n            msg = (\n                f\"Actual column number density of {m} is zero but the reference \"\n                f\"column number density is not ({desired[m]:~P}): rescaling \"\n                f\"is impossible.\"\n            )\n            logger.critical(msg)\n            raise ValueError(msg)\n        else:\n            factors[m] = (desired[m] / actual[m]).m_as(\"dimensionless\")\n\n    return ds.joseki.rescale(factors=factors)\n</code></pre>"},{"location":"reference/#joseki.profiles.core.select_molecules","title":"<code>joseki.profiles.core.select_molecules(ds, molecules)</code>","text":"<p>Select specified molecules in the profile.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Initial atmospheric profile.</p> required <code>molecules</code> <code>List[str]</code> <p>List of molecules to select.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmospheric profile with exactly the specified molecules.</p> Source code in <code>src/joseki/profiles/core.py</code> <pre><code>def select_molecules(\n    ds: xr.Dataset,\n    molecules: t.List[str],\n) -&gt; xr.Dataset:\n    \"\"\"\n    Select specified molecules in the profile.\n\n    Args:\n        ds: Initial atmospheric profile.\n        molecules: List of molecules to select.\n\n    Returns:\n        Atmospheric profile with exactly the specified molecules.\n    \"\"\"\n    drop_molecules = [m for m in ds.joseki.molecules if m not in molecules]\n    ds_dropped = ds.joseki.drop_molecules(drop_molecules)\n\n    if all([m in ds_dropped.joseki.molecules for m in molecules]):\n        return ds_dropped\n    else:\n        raise ValueError(\n            f\"Could not select molecules {molecules}, \"\n            f\"available molecules are {ds.joseki.molecules}.\"\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.schema","title":"<code>joseki.profiles.schema</code>","text":"<p>Dataset schema for atmosphere thermophysical profiles.</p> <p>The dataset schema defines the variables, coordinates and attributes that are expected in a dataset representing an atmosphere thermophysical profile.</p>"},{"location":"reference/#joseki.profiles.schema.Schema","title":"<code>joseki.profiles.schema.Schema</code>","text":"<p>Dataset schema for atmosphere thermophysical profiles.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>@define(frozen=True)\nclass Schema:\n    \"\"\"Dataset schema for atmosphere thermophysical profiles.\"\"\"\n\n    # name: (dims, data type, dimensionality, standard name)\n    data_vars = {\n        \"p\": (\n            [\"z\"],\n            npt.NDArray[np.float64],\n            \"Pa\",\n            \"air_pressure\",\n        ),\n        \"t\": (\n            [\"z\"],\n            npt.NDArray[np.float64],\n            \"K\",\n            \"air_temperature\",\n        ),\n        \"n\": (\n            [\"z\"],\n            npt.NDArray[np.float64],\n            \"m ** -3\",\n            \"air_number_density\",\n        ),\n    }\n\n    coords = {\n        \"z\": (\"z\", npt.NDArray[np.float64], \"km\", \"altitude\"),\n    }\n\n    attrs = {\n        \"Conventions\": str,\n        \"title\": str,\n        \"institution\": str,\n        \"source\": str,\n        \"history\": str,\n        \"references\": str,\n        \"url\": str,\n        \"urldate\": str,\n    }\n\n    def validate(\n        self,\n        ds: xr.Dataset,\n        check_x_sum: bool = False,\n        ret_true_if_valid: bool = False,\n    ) -&gt; t.Optional[bool]:\n        \"\"\"Validate dataset.\n\n        Args:\n            ds: Dataset to validate.\n            check_x_sum: if True, check that mole fraction sums\n                are never larger than one.\n            ret_true_if_valid: make this method return True if the dataset is\n                valid. Note that if the dataset is not valid, this method will\n                raise an exception.\n\n        Raises:\n            ValueError: If the dataset does not match the schema.\n\n        Returns:\n            None or bool: If `ret_true_if_valid` is True, returns True if the\n                dataset is valid, otherwise returns None.\n        \"\"\"\n        logger.debug(\"Validating dataset\")\n\n        logger.debug(\"Checking that all data variables are present\")\n        for var in self.data_vars:\n            if var not in ds.data_vars:\n                raise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\n\n        logger.debug(\"Checking that 'x_*' data variable(s) are present\")\n        if not any([name.startswith(\"x_\") for name in ds.data_vars]):\n            raise ValueError(\n                \"missing data variable starting with x_\"\n            )  # pragma: no cover\n\n        logger.debug(\"Checking that all coordinates are present\")\n        for coord in self.coords:\n            if coord not in ds.coords:\n                raise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\n\n        logger.debug(\"Checking that all attributes are present\")\n        for attr in self.attrs:\n            if attr not in ds.attrs:\n                raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n        logger.debug(\"Checking that data variables have the correct dimensions\")\n        for var, (dims, _, _, _) in self.data_vars.items():\n            if set(ds[var].dims) != set(dims):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect dimensions for {var}. Expected {dims}, \"\n                    f\"got {ds[var].dims}\"\n                )\n\n        logger.debug(\"Checking that coordinates have the correct dimensions\")\n        for coord, (dims, _, _, _) in self.coords.items():\n            if set(ds[coord].dims) != set(dims):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect dimensions for {coord}. Expected {dims}, \"\n                    f\"got {ds[coord].dims}\"\n                )\n\n        logger.debug(\"Checking that data variables have the correct dimensionality\")\n        for var, (_, _, dimensionality, _) in self.data_vars.items():\n            units = ureg(ds[var].units)\n            if not units.check(dimensionality):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect units for {var}. Expected {dimensionality}, \"\n                    f\"got {units.dimensionality}\"\n                )\n\n        logger.debug(\"Checking that coordinates have the correct dimensionality\")\n        for coord, (_, _, dimensionality, _) in self.coords.items():\n            units = ureg(ds[coord].units)\n            if not units.check(dimensionality):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect units for {coord}. Expected {dimensionality}, \"\n                    f\"got {units.dimensionality}\"\n                )\n\n        logger.debug(\"Checking that attributes have the correct types\")\n        for attr, typ in self.attrs.items():\n            if not isinstance(ds.attrs[attr], typ):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect type for {attr}. Expected {typ}, \"\n                    f\"got {type(ds.attrs[attr])}\"\n                )\n\n        logger.debug(\"Checking that data variables have the correct standard names\")\n        for var, (_, _, _, standard_name) in self.data_vars.items():\n            if ds[var].attrs[\"standard_name\"] != standard_name:\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect standard name for {var}. Expected \"\n                    f\"{standard_name}, got \"\n                    f\"{ds[var].attrs['standard_name']}\"\n                )\n\n        logger.debug(\n            \"Checking that all x_* data variables have the correct \"\n            \"dimensionality and standard names\"\n        )\n        for var in ds.data_vars:\n            if var.startswith(\"x_\"):\n                m = var[2:]\n                units = ureg(ds[var].units)\n                if not units.check(\"[]\"):\n                    raise ValueError(  # pragma: no cover\n                        f\"incorrect dimensionality for {var}. Expected \"\n                        f\"dimensionless, got {units.dimensionality}\"\n                    )\n                if ds[var].attrs[\"standard_name\"] != f\"{m}_mole_fraction\":\n                    raise ValueError(  # pragma: no cover\n                        f\"incorrect standard name for {var}. Expected \"\n                        f\"{m}_mole_fraction, got \"\n                        f\"{ds[var].attrs['standard_name']}\"\n                    )\n\n        if check_x_sum:\n            logger.debug(\"Checking that mole fraction sums are never larger than one\")\n            vfs = mole_fraction_sum(ds)\n            if np.any(vfs.m &gt; 1):\n                raise ValueError(  # pragma: no cover\n                    \"The rescaling factors lead to a profile where the mole \"\n                    \"fraction sum is larger than 1.\"\n                )\n\n        logger.info(\"Dataset is valid\")\n\n        if ret_true_if_valid:  # pragma: no cover\n            return True\n\n    def convert(\n        self,\n        data_vars: t.Mapping[str, pint.Quantity],\n        coords: t.Mapping[str, pint.Quantity],\n        attrs: t.Mapping[str, str],\n    ) -&gt; xr.Dataset:\n        \"\"\"Convert input to schema-compliant dataset.\n\n        Args:\n            data_vars: Mapping of data variable names to quantities.\n            coords: Mapping of coordinate names to quantities.\n            attrs: Mapping of attribute names to values.\n\n        Returns:\n            Dataset with schema-compliant data variables, coordinates, and\n            attributes.\n        \"\"\"\n        logger.debug(\"converting input to schema-compliant dataset\")\n\n        logger.debug(\"checking that all data variables are present\")\n        for var in self.data_vars:\n            if var == \"n\" not in data_vars:\n                n = number_density(\n                    p=data_vars[\"p\"],\n                    t=data_vars[\"t\"],\n                )\n                data_vars[\"n\"] = n\n            else:\n                if var not in data_vars:\n                    raise ValueError(\n                        f\"missing data variable: {var}\"\n                    )  # pragma: no cover\n\n        logger.debug(\"checking that there is at least one x_ data variable\")\n        if not any([name.startswith(\"x_\") for name in data_vars]):\n            raise ValueError(\n                \"missing data variable starting with x_\"\n            )  # pragma: no cover\n\n        logger.debug(\"checking that all coordinates are present\")\n        for coord in self.coords:\n            if coord not in coords:\n                raise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\n\n        logger.debug(\"checking that all attributes are present\")\n        for attr in self.attrs:\n            if attr not in attrs:\n                raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n        logger.debug(\"converting data variables to xarray data array tuples\")\n        for var, (dims, _, units, standard_name) in self.data_vars.items():\n            data_vars[var] = (\n                dims,\n                data_vars[var].m_as(units),\n                {\n                    \"standard_name\": standard_name,\n                    \"long_name\": standard_name.replace(\"_\", \" \"),\n                    \"units\": units,\n                },\n            )\n\n        logger.debug(\"converting x_ data variables\")\n        for var in data_vars:\n            if var.startswith(\"x_\"):\n                m = var[2:]\n                data_vars[var] = (\n                    \"z\",\n                    data_vars[var].m_as(\"dimensionless\"),\n                    {\n                        \"standard_name\": f\"{m}_mole_fraction\",\n                        \"long_name\": f\"{m} mole fraction\",\n                        \"units\": \"dimensionless\",\n                    },\n                )\n\n        logger.debug(\"converting coordinates\")\n        for attr, (_, _, units, standard_name) in self.coords.items():\n            coords[attr] = (\n                attr,\n                coords[attr].m_as(units),\n                {\n                    \"standard_name\": standard_name,\n                    \"long_name\": standard_name.replace(\"_\", \" \"),\n                    \"units\": units,\n                },\n            )\n\n        logger.debug(\"checking that all attributes are present\")\n        for attr in self.attrs:\n            if attr not in attrs:\n                raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n        logger.debug(\"creating dataset\")\n        return xr.Dataset(\n            data_vars=data_vars,\n            coords=coords,\n            attrs=attrs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.schema.Schema.convert","title":"<code>joseki.profiles.schema.Schema.convert(data_vars, coords, attrs)</code>","text":"<p>Convert input to schema-compliant dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data_vars</code> <code>Mapping[str, Quantity]</code> <p>Mapping of data variable names to quantities.</p> required <code>coords</code> <code>Mapping[str, Quantity]</code> <p>Mapping of coordinate names to quantities.</p> required <code>attrs</code> <code>Mapping[str, str]</code> <p>Mapping of attribute names to values.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with schema-compliant data variables, coordinates, and</p> <code>Dataset</code> <p>attributes.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def convert(\n    self,\n    data_vars: t.Mapping[str, pint.Quantity],\n    coords: t.Mapping[str, pint.Quantity],\n    attrs: t.Mapping[str, str],\n) -&gt; xr.Dataset:\n    \"\"\"Convert input to schema-compliant dataset.\n\n    Args:\n        data_vars: Mapping of data variable names to quantities.\n        coords: Mapping of coordinate names to quantities.\n        attrs: Mapping of attribute names to values.\n\n    Returns:\n        Dataset with schema-compliant data variables, coordinates, and\n        attributes.\n    \"\"\"\n    logger.debug(\"converting input to schema-compliant dataset\")\n\n    logger.debug(\"checking that all data variables are present\")\n    for var in self.data_vars:\n        if var == \"n\" not in data_vars:\n            n = number_density(\n                p=data_vars[\"p\"],\n                t=data_vars[\"t\"],\n            )\n            data_vars[\"n\"] = n\n        else:\n            if var not in data_vars:\n                raise ValueError(\n                    f\"missing data variable: {var}\"\n                )  # pragma: no cover\n\n    logger.debug(\"checking that there is at least one x_ data variable\")\n    if not any([name.startswith(\"x_\") for name in data_vars]):\n        raise ValueError(\n            \"missing data variable starting with x_\"\n        )  # pragma: no cover\n\n    logger.debug(\"checking that all coordinates are present\")\n    for coord in self.coords:\n        if coord not in coords:\n            raise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\n\n    logger.debug(\"checking that all attributes are present\")\n    for attr in self.attrs:\n        if attr not in attrs:\n            raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n    logger.debug(\"converting data variables to xarray data array tuples\")\n    for var, (dims, _, units, standard_name) in self.data_vars.items():\n        data_vars[var] = (\n            dims,\n            data_vars[var].m_as(units),\n            {\n                \"standard_name\": standard_name,\n                \"long_name\": standard_name.replace(\"_\", \" \"),\n                \"units\": units,\n            },\n        )\n\n    logger.debug(\"converting x_ data variables\")\n    for var in data_vars:\n        if var.startswith(\"x_\"):\n            m = var[2:]\n            data_vars[var] = (\n                \"z\",\n                data_vars[var].m_as(\"dimensionless\"),\n                {\n                    \"standard_name\": f\"{m}_mole_fraction\",\n                    \"long_name\": f\"{m} mole fraction\",\n                    \"units\": \"dimensionless\",\n                },\n            )\n\n    logger.debug(\"converting coordinates\")\n    for attr, (_, _, units, standard_name) in self.coords.items():\n        coords[attr] = (\n            attr,\n            coords[attr].m_as(units),\n            {\n                \"standard_name\": standard_name,\n                \"long_name\": standard_name.replace(\"_\", \" \"),\n                \"units\": units,\n            },\n        )\n\n    logger.debug(\"checking that all attributes are present\")\n    for attr in self.attrs:\n        if attr not in attrs:\n            raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n    logger.debug(\"creating dataset\")\n    return xr.Dataset(\n        data_vars=data_vars,\n        coords=coords,\n        attrs=attrs,\n    )\n</code></pre>"},{"location":"reference/#joseki.profiles.schema.Schema.validate","title":"<code>joseki.profiles.schema.Schema.validate(ds, check_x_sum=False, ret_true_if_valid=False)</code>","text":"<p>Validate dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to validate.</p> required <code>check_x_sum</code> <code>bool</code> <p>if True, check that mole fraction sums are never larger than one.</p> <code>False</code> <code>ret_true_if_valid</code> <code>bool</code> <p>make this method return True if the dataset is valid. Note that if the dataset is not valid, this method will raise an exception.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset does not match the schema.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>None or bool: If <code>ret_true_if_valid</code> is True, returns True if the dataset is valid, otherwise returns None.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def validate(\n    self,\n    ds: xr.Dataset,\n    check_x_sum: bool = False,\n    ret_true_if_valid: bool = False,\n) -&gt; t.Optional[bool]:\n    \"\"\"Validate dataset.\n\n    Args:\n        ds: Dataset to validate.\n        check_x_sum: if True, check that mole fraction sums\n            are never larger than one.\n        ret_true_if_valid: make this method return True if the dataset is\n            valid. Note that if the dataset is not valid, this method will\n            raise an exception.\n\n    Raises:\n        ValueError: If the dataset does not match the schema.\n\n    Returns:\n        None or bool: If `ret_true_if_valid` is True, returns True if the\n            dataset is valid, otherwise returns None.\n    \"\"\"\n    logger.debug(\"Validating dataset\")\n\n    logger.debug(\"Checking that all data variables are present\")\n    for var in self.data_vars:\n        if var not in ds.data_vars:\n            raise ValueError(f\"missing data variable: {var}\")  # pragma: no cover\n\n    logger.debug(\"Checking that 'x_*' data variable(s) are present\")\n    if not any([name.startswith(\"x_\") for name in ds.data_vars]):\n        raise ValueError(\n            \"missing data variable starting with x_\"\n        )  # pragma: no cover\n\n    logger.debug(\"Checking that all coordinates are present\")\n    for coord in self.coords:\n        if coord not in ds.coords:\n            raise ValueError(f\"missing coordinate: {coord}\")  # pragma: no cover\n\n    logger.debug(\"Checking that all attributes are present\")\n    for attr in self.attrs:\n        if attr not in ds.attrs:\n            raise ValueError(f\"missing attribute: {attr}\")  # pragma: no cover\n\n    logger.debug(\"Checking that data variables have the correct dimensions\")\n    for var, (dims, _, _, _) in self.data_vars.items():\n        if set(ds[var].dims) != set(dims):\n            raise ValueError(  # pragma: no cover\n                f\"incorrect dimensions for {var}. Expected {dims}, \"\n                f\"got {ds[var].dims}\"\n            )\n\n    logger.debug(\"Checking that coordinates have the correct dimensions\")\n    for coord, (dims, _, _, _) in self.coords.items():\n        if set(ds[coord].dims) != set(dims):\n            raise ValueError(  # pragma: no cover\n                f\"incorrect dimensions for {coord}. Expected {dims}, \"\n                f\"got {ds[coord].dims}\"\n            )\n\n    logger.debug(\"Checking that data variables have the correct dimensionality\")\n    for var, (_, _, dimensionality, _) in self.data_vars.items():\n        units = ureg(ds[var].units)\n        if not units.check(dimensionality):\n            raise ValueError(  # pragma: no cover\n                f\"incorrect units for {var}. Expected {dimensionality}, \"\n                f\"got {units.dimensionality}\"\n            )\n\n    logger.debug(\"Checking that coordinates have the correct dimensionality\")\n    for coord, (_, _, dimensionality, _) in self.coords.items():\n        units = ureg(ds[coord].units)\n        if not units.check(dimensionality):\n            raise ValueError(  # pragma: no cover\n                f\"incorrect units for {coord}. Expected {dimensionality}, \"\n                f\"got {units.dimensionality}\"\n            )\n\n    logger.debug(\"Checking that attributes have the correct types\")\n    for attr, typ in self.attrs.items():\n        if not isinstance(ds.attrs[attr], typ):\n            raise ValueError(  # pragma: no cover\n                f\"incorrect type for {attr}. Expected {typ}, \"\n                f\"got {type(ds.attrs[attr])}\"\n            )\n\n    logger.debug(\"Checking that data variables have the correct standard names\")\n    for var, (_, _, _, standard_name) in self.data_vars.items():\n        if ds[var].attrs[\"standard_name\"] != standard_name:\n            raise ValueError(  # pragma: no cover\n                f\"incorrect standard name for {var}. Expected \"\n                f\"{standard_name}, got \"\n                f\"{ds[var].attrs['standard_name']}\"\n            )\n\n    logger.debug(\n        \"Checking that all x_* data variables have the correct \"\n        \"dimensionality and standard names\"\n    )\n    for var in ds.data_vars:\n        if var.startswith(\"x_\"):\n            m = var[2:]\n            units = ureg(ds[var].units)\n            if not units.check(\"[]\"):\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect dimensionality for {var}. Expected \"\n                    f\"dimensionless, got {units.dimensionality}\"\n                )\n            if ds[var].attrs[\"standard_name\"] != f\"{m}_mole_fraction\":\n                raise ValueError(  # pragma: no cover\n                    f\"incorrect standard name for {var}. Expected \"\n                    f\"{m}_mole_fraction, got \"\n                    f\"{ds[var].attrs['standard_name']}\"\n                )\n\n    if check_x_sum:\n        logger.debug(\"Checking that mole fraction sums are never larger than one\")\n        vfs = mole_fraction_sum(ds)\n        if np.any(vfs.m &gt; 1):\n            raise ValueError(  # pragma: no cover\n                \"The rescaling factors lead to a profile where the mole \"\n                \"fraction sum is larger than 1.\"\n            )\n\n    logger.info(\"Dataset is valid\")\n\n    if ret_true_if_valid:  # pragma: no cover\n        return True\n</code></pre>"},{"location":"reference/#joseki.profiles.schema.mole_fraction_sum","title":"<code>joseki.profiles.schema.mole_fraction_sum(ds)</code>","text":"<p>Compute the sum of mole fractions.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset.</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>The sum of mole fractions.</p> Source code in <code>src/joseki/profiles/schema.py</code> <pre><code>def mole_fraction_sum(ds: xr.Dataset) -&gt; pint.Quantity:\n    \"\"\"Compute the sum of mole fractions.\n\n    Args:\n        ds: Dataset.\n\n    Returns:\n        The sum of mole fractions.\n    \"\"\"\n    return (\n        sum([ds[c] for c in ds.data_vars if c.startswith(\"x_\")]).values\n        * ureg.dimensionless\n    )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986","title":"<code>joseki.profiles.afgl_1986</code>","text":"<p>AFGL 1986 atmosphere's thermophysical profiles.</p> <p>The profiles are generated from data files stored in <code>joseki/data/afgl_1986</code>. These data files correspond to tables 1a-f and 2a-d of the technical report Anderson+1986.</p>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986MidlatitudeSummer","title":"<code>joseki.profiles.afgl_1986.AFGL1986MidlatitudeSummer</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 midlatitude summer atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-midlatitude_summer\")\n@define\nclass AFGL1986MidlatitudeSummer(Profile):\n    \"\"\"AFGL 1986 midlatitude summer atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 midlatitude summer atmosphere thermophysical \"\n            \"profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.MIDLATITUDE_SUMMER,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986MidlatitudeWinter","title":"<code>joseki.profiles.afgl_1986.AFGL1986MidlatitudeWinter</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 midlatitude winter atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-midlatitude_winter\")\n@define\nclass AFGL1986MidlatitudeWinter(Profile):\n    \"\"\"AFGL 1986 midlatitude winter atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 midlatitude winter atmosphere thermophysical \"\n            \"profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.MIDLATITUDE_WINTER,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986SubarcticSummer","title":"<code>joseki.profiles.afgl_1986.AFGL1986SubarcticSummer</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 subarctic summer atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-subarctic_summer\")\n@define\nclass AFGL1986SubarcticSummer(Profile):\n    \"\"\"AFGL 1986 subarctic summer atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 subarctic summer atmosphere thermophysical \"\n            \"profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.SUBARCTIC_SUMMER,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986SubarcticWinter","title":"<code>joseki.profiles.afgl_1986.AFGL1986SubarcticWinter</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 subarctic winter atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-subarctic_winter\")\n@define\nclass AFGL1986SubarcticWinter(Profile):\n    \"\"\"AFGL 1986 subarctic winter atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 subarctic winter atmosphere thermophysical \"\n            \"profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.SUBARCTIC_WINTER,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986Tropical","title":"<code>joseki.profiles.afgl_1986.AFGL1986Tropical</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 tropical atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-tropical\")\n@define\nclass AFGL1986Tropical(Profile):\n    \"\"\"AFGL 1986 tropical atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 tropical atmosphere thermophysical profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.TROPICAL,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.AFGL1986USStandard","title":"<code>joseki.profiles.afgl_1986.AFGL1986USStandard</code>","text":"<p>             Bases: <code>Profile</code></p> <p>AFGL 1986 US Standard atmosphere thermophysical profile.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>@factory.register(identifier=\"afgl_1986-us_standard\")\n@define\nclass AFGL1986USStandard(Profile):\n    \"\"\"AFGL 1986 US Standard atmosphere thermophysical profile.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        logger.debug(\n            \"creating AFGL 1986 US Standard atmosphere thermophysical profile dataset.\"\n        )\n        return to_dataset(\n            identifier=Identifier.US_STANDARD,\n            z=z,\n            interp_method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.Identifier","title":"<code>joseki.profiles.afgl_1986.Identifier</code>","text":"<p>             Bases: <code>Enum</code></p> <p>AFGL 1986 atmospheric profile identifier enumeration.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>class Identifier(enum.Enum):\n    \"\"\"AFGL 1986 atmospheric profile identifier enumeration.\"\"\"\n\n    TROPICAL = \"tropical\"\n    MIDLATITUDE_SUMMER = \"midlatitude_summer\"\n    MIDLATITUDE_WINTER = \"midlatitude_winter\"\n    SUBARCTIC_SUMMER = \"subarctic_summer\"\n    SUBARCTIC_WINTER = \"subarctic_winter\"\n    US_STANDARD = \"us_standard\"\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.dataframe_to_dataset","title":"<code>joseki.profiles.afgl_1986.dataframe_to_dataset(df, identifier, additional_molecules=True)</code>","text":"<p>Convert the output of the <code>parse</code> method to a <code>xarray.Dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Atmospheric profile data.</p> required <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier.</p> required <code>additional_molecules</code> <code>bool</code> <p>If <code>True</code>, include molecules 8-28 as numbered in Anderson+1986. Else, discard molecules 8-28.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmospheric profile dataset.</p> Notes <p>Use the <code>z</code> column of the output pandas.DataFrame of read_raw_data as data coordinate and all other columns as data variables. All data variables and coordinates of the returned xarray.Dataset are associated metadata (standard name, long name and units). Raw data units are documented in the technical report AFGL Atmospheric Constituent Profiles (0-120 km), Anderson et al., 1986 Anderson+1986. dataset attributes are added.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def dataframe_to_dataset(\n    df: pd.DataFrame,\n    identifier: Identifier,\n    additional_molecules: bool = True,\n) -&gt; xr.Dataset:\n    \"\"\"Convert the output of the `parse` method to a `xarray.Dataset`.\n\n    Args:\n        df: Atmospheric profile data.\n        identifier: Atmospheric profile identifier.\n        additional_molecules: If ``True``, include molecules 8-28 as numbered\n            in [Anderson+1986](bibliography.md#Anderson+1986).\n            Else, discard molecules 8-28.\n\n    Returns:\n        Atmospheric profile dataset.\n\n    Notes:\n        Use the ``z`` column of the output pandas.DataFrame of read_raw_data\n        as data coordinate and all other columns as data variables.\n        All data variables and coordinates of the returned xarray.Dataset are\n        associated metadata (standard name, long name and units).\n        Raw data units are documented in the technical report *AFGL Atmospheric\n        Constituent Profiles (0-120 km)*, Anderson et al., 1986\n        [Anderson+1986](bibliography.md#Anderson+1986).\n        dataset attributes are added.\n    \"\"\"\n    # list molecules\n    # molecules labels correspond to column with upper case first letter in\n    # raw data DataFrames\n    molecules = []\n    for column in df.columns:\n        if column[0].isupper():\n            molecules.append(column)\n\n    if additional_molecules:\n        pass\n    else:\n        molecules = molecules[:7]\n\n    # coordinates\n    coords = {\"z\": ureg.Quantity(df.z.values, \"km\")}\n\n    # data variables\n    data_vars = {}\n    data_vars[\"p\"] = ureg.Quantity(df.p.values, \"millibar\").to(\"Pa\")\n    data_vars[\"t\"] = ureg.Quantity(df.t.values, \"K\")\n    data_vars[\"n\"] = ureg.Quantity(df.n.values, \"cm^-3\").to(\"m^-3\")\n\n    for s in molecules:\n        data_vars[f\"x_{s}\"] = (\n            df[s].values * ureg.ppm\n        )  # raw data mole fraction are given in ppmv\n\n    # attributes\n    pretty_identifier = f\"AFGL (1986) {identifier.value.replace('_', '-')}\"\n    pretty_title = f\"{pretty_identifier} atmosphere thermophysical profile\"\n\n    attrs = {\n        \"Conventions\": \"CF-1.10\",\n        \"title\": pretty_title,\n        \"institution\": INSTITUION,\n        \"source\": SOURCE,\n        \"history\": history(),\n        \"references\": REFERENCE,\n        \"url\": URL,\n        \"urldate\": URLDATE,\n    }\n\n    return schema.convert(\n        data_vars=data_vars,\n        coords=coords,\n        attrs=attrs,\n    )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.get_dataset","title":"<code>joseki.profiles.afgl_1986.get_dataset(identifier, additional_molecules=True)</code>","text":"<p>Read data files for a given atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See <code>Identifier</code> for possible values.</p> required <code>additional_molecules</code> <code>bool</code> <p>If <code>True</code>, include molecules 8-28 as numbered in Anderson+1986. Else, discard molecules 8-28.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmospheric profile dataset.</p> Notes <p>Chain calls to <code>parse</code> and <code>dataframe_to_dataset</code>.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def get_dataset(\n    identifier: Identifier,\n    additional_molecules: bool = True,\n) -&gt; xr.Dataset:\n    \"\"\"Read data files for a given atmospheric profile.\n\n    Args:\n        identifier: Atmospheric profile identifier.\n            See\n            [`Identifier`](reference.md#src.joseki.profiles.afgl_1986.Identifier)\n            for possible values.\n        additional_molecules: If ``True``, include molecules 8-28 as numbered in\n            [Anderson+1986](bibliography.md#Anderson+1986).\n            Else, discard molecules 8-28.\n\n    Returns:\n        Atmospheric profile dataset.\n\n    Notes:\n        Chain calls to\n        [`parse`](reference.md#src.joseki.profiles.afgl_1986.parse) and\n        [`dataframe_to_dataset`](reference.md#src.joseki.profiles.afgl_1986.dataframe_to_dataset).\n\n    \"\"\"\n    df = parse(identifier=identifier)\n    return dataframe_to_dataset(\n        df=df,\n        identifier=identifier,\n        additional_molecules=additional_molecules,\n    )\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.parse","title":"<code>joseki.profiles.afgl_1986.parse(identifier)</code>","text":"<p>Parse table data files for a given atmospheric profile.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Atmospheric profile dataset.</p> Notes <p>Read the relevant raw data files corresponding to the atmospheric profile. These raw data files correspond to tables 1 and 2 from the technical report AFGL Atmospheric Constituent Profiles (0-120 km), Anderson et al., 1986. Each atmospheric profile has 5 tables, i.e. 5 raw data files, associated to it. Only the first of these tables is specific to each atmospheric profile. All 5 raw data files are read into <code>pandas.DataFrame</code> objects and then concatenated after dropping the duplicate columns.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def parse(identifier: Identifier) -&gt; pd.DataFrame:\n    \"\"\"Parse table data files for a given atmospheric profile.\n\n    Args:\n        identifier: Atmospheric profile identifier.\n\n    Returns:\n        Atmospheric profile dataset.\n\n    Notes:\n        Read the relevant raw data files corresponding to the atmospheric profile.\n        These raw data files correspond to tables 1 and 2 from the\n        technical report [*AFGL Atmospheric Constituent Profiles (0-120 km)*,\n        Anderson et al., 1986](bibliography.md#Anderson+1986).\n        Each atmospheric profile has 5 tables, i.e. 5 raw data files, associated\n        to it.\n        Only the first of these tables is specific to each atmospheric profile.\n        All 5 raw data files are read into `pandas.DataFrame` objects and\n        then concatenated after dropping the duplicate columns.\n    \"\"\"\n    package = \"joseki.data.afgl_1986\"\n    files = DATA_FILES[identifier]\n    dataframes = []\n    for file in files:\n        csvfile = importlib_resources.files(package).joinpath(file)\n        df = pd.read_csv(csvfile)\n        dataframes.append(df)\n    dataframes[1] = dataframes[1].drop([\"H2O\", \"O3\", \"N2O\", \"CO\", \"CH4\"], axis=1)\n    for i in range(1, 5):\n        dataframes[i] = dataframes[i].drop(\"z\", axis=1)\n\n    return pd.concat(dataframes, axis=1)\n</code></pre>"},{"location":"reference/#joseki.profiles.afgl_1986.to_dataset","title":"<code>joseki.profiles.afgl_1986.to_dataset(identifier, z=None, interp_method=None, conserve_column=False, **kwargs)</code>","text":"<p>Helper Profile.to_dataset() method.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>AFGL 1986 atmosphere thermophysical profile identifier. See <code>Identifier</code> for possible values.</p> required <code>z</code> <code>Optional[Quantity]</code> <p>New level altitudes. If <code>None</code>, return the original dataset Else, interpolate the dataset to the new level altitudes. Default is <code>None</code>.</p> <code>None</code> <code>interp_method</code> <code>Mapping[str, str]</code> <p>Interpolation method for each data variable. Default is <code>None</code>.</p> <code>None</code> <code>conserve_column</code> <code>bool</code> <p>If <code>True</code>, ensure that column densities are conserved during interpolation.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>get_dataset</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmosphere thermophysical profile dataset.</p> Source code in <code>src/joseki/profiles/afgl_1986.py</code> <pre><code>def to_dataset(\n    identifier: Identifier,\n    z: t.Optional[pint.Quantity] = None,\n    interp_method: t.Mapping[str, str] = None,\n    conserve_column: bool = False,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Helper Profile.to_dataset() method.\n\n    Args:\n        identifier: AFGL 1986 atmosphere thermophysical profile identifier.\n            See\n            [`Identifier`](reference.md#src.joseki.profiles.afgl_1986.Identifier)\n            for possible values.\n        z: New level altitudes.\n            If ``None``, return the original dataset\n            Else, interpolate the dataset to the new level altitudes.\n            Default is ``None``.\n        interp_method: Interpolation method for each data variable. Default is\n            ``None``.\n        conserve_column: If `True`, ensure that column densities are conserved\n            during interpolation.\n        kwargs: Additional arguments passed to\n            [`get_dataset`](reference.md#src.joseki.profiles.afgl_1986.get_dataset).\n\n    Returns:\n        Atmosphere thermophysical profile dataset.\n    \"\"\"\n    # Get additional_molecules from kwargs\n    additional_molecules = kwargs.get(\"additional_molecules\", True)\n\n    # kwargs different than 'additional_molecules' are ignored\n    if len([x for x in kwargs.keys() if x != \"additional_molecules\"]) &gt; 0:\n        logger.warning(\n            \"Ignoring kwargs different than 'additional_molecules'. \"\n            \"(got %s)\"\n            \"Use 'additional_molecules' to include molecules 8-28 \"\n            \"as numbered in Anderson et al. (1986).\",\n            kwargs,\n        )\n\n    # Get the original dataset\n    ds = get_dataset(\n        identifier=identifier,\n        additional_molecules=additional_molecules,\n    )\n\n    # Interpolate if necessary\n    if z is not None:\n        method = interp_method if interp_method is not None else DEFAULT_METHOD\n        ds = interp(\n            ds=ds,\n            z_new=z,\n            method=method,\n            conserve_column=conserve_column,\n        )\n        return ds\n    else:\n        return ds\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007","title":"<code>joseki.profiles.mipas_2007</code>","text":"<p>MIPAS atmosphere thermophysical profiles.</p> <p>Remedios et al. (2007) define a set of 5 \"standard atmospheres\" representing the atmosphere at different latitudes and seasons or times of day:</p> <ul> <li>midlatitude day</li> <li>midlatitude night</li> <li>polar winter</li> <li>polar summer</li> <li>tropical</li> </ul> <p>MIPAS standard atmospheres were intended to provide an updated set of pro- files for characteristic atmospheric states such as the AFGL Atmospheric constituent profiles.</p>"},{"location":"reference/#joseki.profiles.mipas_2007.Identifier","title":"<code>joseki.profiles.mipas_2007.Identifier</code>","text":"<p>             Bases: <code>Enum</code></p> <p>MIPAS atmosphere thermophysical profile identifier enumeration.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>class Identifier(enum.Enum):\n    \"\"\"MIPAS atmosphere thermophysical profile identifier enumeration.\"\"\"\n\n    MIDLATITUDE_DAY = \"midlatitude_day\"\n    MIDLATITUDE_NIGHT = \"midlatitude_night\"\n    POLAR_WINTER = \"polar_winter\"\n    POLAR_SUMMER = \"polar_summer\"\n    TROPICAL = \"tropical\"\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.MIPASMidlatitudeDay","title":"<code>joseki.profiles.mipas_2007.MIPASMidlatitudeDay</code>","text":"<p>             Bases: <code>Profile</code></p> <p>MIPAS midlatitude day reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-midlatitude_day\")\n@define\nclass MIPASMidlatitudeDay(Profile):\n    \"\"\"MIPAS midlatitude day reference atmosphere.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        return to_dataset(\n            identifier=Identifier.MIDLATITUDE_DAY,\n            z=z,\n            method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.MIPASMidlatitudeNight","title":"<code>joseki.profiles.mipas_2007.MIPASMidlatitudeNight</code>","text":"<p>             Bases: <code>Profile</code></p> <p>MIPAS Midlatitude night reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-midlatitude_night\")\n@define\nclass MIPASMidlatitudeNight(Profile):\n    \"\"\"MIPAS Midlatitude night reference atmosphere.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        return to_dataset(\n            identifier=Identifier.MIDLATITUDE_NIGHT,\n            z=z,\n            method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.MIPASPolarSummer","title":"<code>joseki.profiles.mipas_2007.MIPASPolarSummer</code>","text":"<p>             Bases: <code>Profile</code></p> <p>MIPAS Polar summer reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-polar_summer\")\n@define\nclass MIPASPolarSummer(Profile):\n    \"\"\"MIPAS Polar summer reference atmosphere.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        return to_dataset(\n            identifier=Identifier.POLAR_SUMMER,\n            z=z,\n            method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.MIPASPolarWinter","title":"<code>joseki.profiles.mipas_2007.MIPASPolarWinter</code>","text":"<p>             Bases: <code>Profile</code></p> <p>MIPAS Polar winter reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-polar_winter\")\n@define\nclass MIPASPolarWinter(Profile):\n    \"\"\"MIPAS Polar winter reference atmosphere.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        return to_dataset(\n            identifier=Identifier.POLAR_WINTER,\n            z=z,\n            method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.MIPASTropical","title":"<code>joseki.profiles.mipas_2007.MIPASTropical</code>","text":"<p>             Bases: <code>Profile</code></p> <p>MIPAS Tropical reference atmosphere.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>@factory.register(\"mipas_2007-tropical\")\n@define\nclass MIPASTropical(Profile):\n    \"\"\"MIPAS Tropical reference atmosphere.\"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        return to_dataset(\n            identifier=Identifier.TROPICAL,\n            z=z,\n            method=interp_method,\n            conserve_column=conserve_column,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.get_dataset","title":"<code>joseki.profiles.mipas_2007.get_dataset(identifier)</code>","text":"<p>Read MIPAS reference atmosphere data files into an xarray.Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See <code>Identifier</code> for possible values.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Atmospheric profile.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def get_dataset(identifier: Identifier) -&gt; xr.Dataset:\n    \"\"\"Read MIPAS reference atmosphere data files into an xarray.Dataset.\n\n    Args:\n        identifier: Atmospheric profile identifier.\n            See\n            [`Identifier`](reference.md#src.joseki.profiles.mipas_2007.Identifier)\n            for possible values.\n\n    Returns:\n        Atmospheric profile.\n    \"\"\"\n    content = read_file_content(identifier=identifier)\n    quantities = parse_content(content.splitlines())\n\n    # Coordinates\n    coords = {\"z\": quantities.pop(\"z\")}\n\n    # Data variables\n    data_vars = {}\n    p = quantities.pop(\"p\")\n    data_vars[\"p\"] = p\n    t = quantities.pop(\"t\")\n    data_vars[\"t\"] = t\n    n = p / (K * t)  # perfect gas equation\n    data_vars[\"n\"] = n\n    data_vars.update(quantities)\n\n    logger.debug(\"data variables: %s\", data_vars.keys())\n\n    # Attributes\n    pretty_id = identifier.value.replace(\"_\", \" \")\n    pretty_title = f\"MIPAS {pretty_id} Reference Atmosphere\"\n    attrs = {\n        \"Conventions\": \"CF-1.10\",\n        \"history\": history(),\n        \"title\": pretty_title,\n        \"source\": SOURCE,\n        \"institution\": INSTITUTION,\n        \"references\": REFERENCE,\n        \"url\": URL,\n        \"urldate\": URL_DATE,\n    }\n\n    # Dataset\n    ds = schema.convert(\n        data_vars=data_vars,\n        coords=coords,\n        attrs=attrs,\n    )\n\n    return ds\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.parse_content","title":"<code>joseki.profiles.mipas_2007.parse_content(lines)</code>","text":"<p>Parse lines.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_content(lines: t.List[str]) -&gt; t.Dict[str, pint.Quantity]:\n    \"\"\"Parse lines.\"\"\"\n    logger.debug(\"Parsing file content\")\n    iterator = iter(lines)\n    line = next(iterator)\n\n    quantities: t.Dict[str, pint.Quantity] = {}\n\n    def _add_to_quantities(quantity: pint.Quantity, name: str) -&gt; None:\n        if name not in [\"z\", \"p\", \"t\", \"n\"]:\n            name = f\"x_{name}\"\n\n        if quantity.check(\"\"):\n            quantities[name] = quantity.to(\"dimensionless\")\n        else:\n            quantities[name] = quantity\n\n    var: str = \"\"\n    units: str = \"\"\n    values: t.List[str] = []\n    while line != \"*END\":\n        if line.startswith(\"!\"):\n            pass  # this is a comment, ignore the line\n        elif line.startswith(\"*\"):\n            # convert previously read values (if any) and units to quantity\n            if len(values) &gt; 0:\n                quantity = ureg.Quantity(\n                    np.array(values, dtype=float),\n                    units,\n                )\n                _add_to_quantities(quantity=quantity, name=var)\n\n            # this is a variable line, parse variable name and units\n            var, units = parse_var_line(line)\n\n            # following lines are the variables values so prepare a variable\n            # to store the values\n            values = []\n        else:\n            if \"!\" in line:\n                # this the line with the number of profile levels, ignore it\n                pass\n            else:\n                # this line contains variable values\n                values += parse_values_line(line)\n        line = next(iterator)\n\n    # include last array of values before the '*END' line\n    quantity = ureg.Quantity(np.array(values, dtype=float), units)\n    _add_to_quantities(quantity=quantity, name=var)\n\n    return quantities\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.parse_units","title":"<code>joseki.profiles.mipas_2007.parse_units(s)</code>","text":"<p>Parse units.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_units(s: str) -&gt; str:\n    \"\"\"Parse units.\"\"\"\n    if s.startswith(\"[\") and s.endswith(\"]\"):\n        units = s[1:-1]\n        if units == \"mb\":\n            return \"millibar\"\n        else:\n            return units\n    else:\n        raise ValueError(f\"Cannot parse units '{s}'\")\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.parse_values_line","title":"<code>joseki.profiles.mipas_2007.parse_values_line(s)</code>","text":"<p>Parse a line with numeric values.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_values_line(s: str) -&gt; t.List[str]:\n    \"\"\"Parse a line with numeric values.\"\"\"\n    if \",\" in s:  # delimiter is comma and whitespace combined\n        s_strip = s.strip()\n        if s_strip[-1] == \",\":\n            s_strip = s_strip[:-1]\n        return [x.strip() for x in s_strip.split(\",\")]\n    else:  # delimiter is whitespace\n        return s.split()\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.parse_var_line","title":"<code>joseki.profiles.mipas_2007.parse_var_line(s)</code>","text":"<p>Parse a line with the declaration of a variable and its units.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_var_line(s: str) -&gt; t.Tuple[str, str]:\n    \"\"\"Parse a line with the declaration of a variable and its units.\"\"\"\n    parts = s[1:].strip().split()\n    if len(parts) == 2:\n        var_name, units_s = parts\n    elif len(parts) == 3:\n        var_name, _, units_s = parts\n    else:\n        raise ValueError(f\"Invalid line format: {s}\")\n    var = parse_var_name(var_name)\n    units = parse_units(units_s)\n    return var, units\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.parse_var_name","title":"<code>joseki.profiles.mipas_2007.parse_var_name(n)</code>","text":"<p>Parse variable name.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def parse_var_name(n: str) -&gt; str:\n    \"\"\"Parse variable name.\"\"\"\n    translate = {\"HGT\": \"z\", \"PRE\": \"p\", \"TEM\": \"t\"}\n    if n in translate.keys():\n        return translate[n]\n    else:\n        return to_chemical_formula(n)\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.read_file_content","title":"<code>joseki.profiles.mipas_2007.read_file_content(identifier)</code>","text":"<p>Read data file content.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Identifier</code> <p>Atmospheric profile identifier. See <code>Identifier</code> for possible values.</p> required <p>Returns:</p> Type Description <code>str</code> <p>file content, URL, URL date.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def read_file_content(identifier: Identifier) -&gt; str:\n    \"\"\"\n    Read data file content.\n\n    Args:\n        identifier: Atmospheric profile identifier.\n            See\n            [`Identifier`](reference.md#src.joseki.profiles.mipas_2007.Identifier)\n            for possible values.\n\n    Returns:\n        file content, URL, URL date.\n    \"\"\"\n    package = \"joseki.data.mipas_2007\"\n    file = f\"{identifier.value}.atm\"\n    logger.debug(f\"Reading file {file}\")\n    return importlib_resources.files(package).joinpath(file).read_text()\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.to_chemical_formula","title":"<code>joseki.profiles.mipas_2007.to_chemical_formula(name)</code>","text":"<p>Convert to chemical formula.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Molecule name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Molecule formula.</p> Notes <p>If molecule name is unknown, returns name unchanged.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def to_chemical_formula(name: str) -&gt; str:\n    \"\"\"Convert to chemical formula.\n\n    Args:\n        name: Molecule name.\n\n    Returns:\n        Molecule formula.\n\n    Notes:\n        If molecule name is unknown, returns name unchanged.\n    \"\"\"\n    try:\n        return translate_cfc(name)\n    except ValueError:\n        return name\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.to_dataset","title":"<code>joseki.profiles.mipas_2007.to_dataset(identifier, z=None, method=None, conserve_column=False, **kwargs)</code>","text":"<p>Helper for <code>Profile.to_dataset</code> method</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def to_dataset(\n    identifier: Identifier,\n    z: t.Optional[pint.Quantity] = None,\n    method: t.Optional[t.Mapping[str, str]] = None,\n    conserve_column: bool = False,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"Helper for `Profile.to_dataset` method\"\"\"\n    # no kwargs are expected\n    if len(kwargs) &gt; 0:  # pragma: no cover\n        logger.warning(\"Unexpected keyword arguments: %s\", kwargs)\n\n    # get original MIPAS midlatitude day reference atmosphere\n    logger.debug(\"Get original MIPAS midlatitude day reference atmosphere\")\n    ds = get_dataset(identifier=identifier)\n\n    # Interpolate to new vertical grid if necessary\n    if z is not None:\n        method = DEFAULT_METHOD if method is None else method\n        ds = interp(\n            ds=ds,\n            z_new=z,\n            method=method,\n            conserve_column=conserve_column,\n        )\n        return ds\n    else:\n        return ds\n</code></pre>"},{"location":"reference/#joseki.profiles.mipas_2007.translate_cfc","title":"<code>joseki.profiles.mipas_2007.translate_cfc(name)</code>","text":"<p>Convert chlorofulorocarbon name to corresponding chemical formula.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Chlorofulorocarbon name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Chlorofulorocarbon chemical formula.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name does not match a known chlorofulorocarbon.</p> Source code in <code>src/joseki/profiles/mipas_2007.py</code> <pre><code>def translate_cfc(name: str) -&gt; str:\n    \"\"\"Convert chlorofulorocarbon name to corresponding chemical formula.\n\n    Args:\n        name: Chlorofulorocarbon name.\n\n    Returns:\n        Chlorofulorocarbon chemical formula.\n\n    Raises:\n        ValueError: If the name does not match a known chlorofulorocarbon.\n    \"\"\"\n    for formula, names in CFC_FORMULAE.items():\n        if name in names:\n            return formula\n    raise ValueError(\"Unknown chlorofulorocarbon {name}\")\n</code></pre>"},{"location":"reference/#joseki.profiles.ussa_1976","title":"<code>joseki.profiles.ussa_1976</code>","text":"<p>Module to compute the U.S. Standard Atmosphere 1976.</p> <p>The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model described in the technical report NOAA+1976.</p>"},{"location":"reference/#joseki.profiles.ussa_1976.USSA1976","title":"<code>joseki.profiles.ussa_1976.USSA1976</code>","text":"<p>             Bases: <code>Profile</code></p> <p>Class to compute the U.S. Standard Atmosphere 1976.</p> <p>The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model described in the technical report NOAA+1976.</p> Source code in <code>src/joseki/profiles/ussa_1976.py</code> <pre><code>@factory.register(identifier=\"ussa_1976\")\n@define\nclass USSA1976(Profile):\n    \"\"\"\n    Class to compute the U.S. Standard Atmosphere 1976.\n\n    The U.S. Standard Atmosphere 1976 is a Earth atmosphere thermophysical model\n    described in the technical report [NOAA+1976](bibliography.md#NOAA+1976).\n    \"\"\"\n\n    def to_dataset(\n        self,\n        z: t.Optional[pint.Quantity] = None,\n        interp_method: t.Optional[t.Mapping[str, str]] = None,\n        conserve_column: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; xr.Dataset:\n        # Since the ussa_1976 model can be evaluated at any altitude, both\n        # interp_method and conserve_column are ignored.\n\n        # kwargs are ignored\n        if kwargs:\n            logger.warning(  # pragma: no cover\n                \"value of the 'kwargs' parameter will be ignored.\"\n            )\n\n        # variable to compute with the ussa1976 package\n        variables = [\n            \"p\",\n            \"t\",\n            \"n_tot\",\n            \"n\",\n        ]\n        # compute profile\n        if z is None:\n            logging.debug(\"Computing profile with ussa1976 package\")\n            ds = ussa1976.compute(variables=variables)\n        else:\n            logging.debug(\"Computing profile with ussa1976 package\")\n            logging.debug(\"z=%s\", z)\n            ds = ussa1976.compute(z=z.m_as(\"m\"), variables=variables)\n\n        # extract data\n        coords = {\"z\": to_quantity(ds[\"z\"]).to(\"km\")}\n\n        data_vars = {}\n        data_vars[\"p\"] = to_quantity(ds[\"p\"]).to(\"Pa\")\n        data_vars[\"t\"] = to_quantity(ds[\"t\"]).to(\"K\")\n        data_vars[\"n\"] = to_quantity(ds[\"n_tot\"]).to(\"m^-3\")\n\n        # compute mole fraction\n        for s in ds[\"s\"].values:\n            nx = to_quantity(ds[\"n\"].sel(s=s))\n            n_tot = to_quantity(ds[\"n_tot\"])\n            data_vars[f\"x_{s}\"] = (nx / n_tot).to(\"dimensionless\")\n\n        attrs = {\n            \"Conventions\": \"CF-1.10\",\n            \"title\": \"U.S. Standard Atmosphere 1976\",\n            \"institution\": \"NOAA\",\n            \"source\": ds.attrs[\"source\"],\n            \"history\": ds.attrs[\"history\"] + \"\\n\" + history(),\n            \"references\": ds.attrs[\"references\"],\n            \"url\": \"https://ntrs.nasa.gov/citations/19770009539\",\n            \"urldate\": \"2022-12-08\",\n        }\n\n        ds = schema.convert(\n            data_vars,\n            coords,\n            attrs,\n        )\n\n        return ds\n</code></pre>"},{"location":"reference/#joseki.profiles.util","title":"<code>joseki.profiles.util</code>","text":"<p>Utility module.</p>"},{"location":"reference/#joseki.profiles.util.air_molar_mass_from_mass_fraction","title":"<code>joseki.profiles.util.air_molar_mass_from_mass_fraction(y)</code>","text":"<p>Compute the air molar mass from the of air constituents mass fractions.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>DataArray</code> <p>Mass fraction as a function of molecule (<code>m</code>) and altitude (<code>z</code>).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Air molar mass as a function of altitude (<code>z</code>).</p> Notes <p>The air molar mass is computed according to the following equation:</p> \\[ m_{\\mathrm{air}} (z) = \\left(     \\sum_{\\mathrm{M}} \\frac{         y_{\\mathrm{M}} (z)     }{         m_{\\mathrm{M}}     } \\right)^{-1} \\] <p>where:</p> <ul> <li>\\(y_{\\mathrm{M}} (z)\\) is the mass fraction of molecule M at altitude   \\(z\\),</li> <li>\\(m_{\\mathrm{M}}\\) is the molar mass of molecule M.</li> </ul> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def air_molar_mass_from_mass_fraction(y: xr.DataArray) -&gt; xr.DataArray:\n    r\"\"\"\n    Compute the air molar mass from the of air constituents mass fractions.\n\n    Args:\n        y: Mass fraction as a function of molecule (`m`) and altitude (`z`).\n\n    Returns:\n        Air molar mass as a function of altitude (`z`).\n\n    Notes:\n        The air molar mass is computed according to the following equation:\n\n        $$\n        m_{\\mathrm{air}} (z) = \\left(\n            \\sum_{\\mathrm{M}} \\frac{\n                y_{\\mathrm{M}} (z)\n            }{\n                m_{\\mathrm{M}}\n            }\n        \\right)^{-1}\n        $$\n\n        where:\n\n        * $y_{\\mathrm{M}} (z)$ is the mass fraction of molecule M at altitude\n          $z$,\n        * $m_{\\mathrm{M}}$ is the molar mass of molecule M.\n    \"\"\"\n    # compute molar masses along molecular species\n    molecules = y.m.values\n    mm = xr.DataArray(\n        data=[MM[m] for m in molecules],\n        coords={\"m\": (\"m\", molecules)},\n    )\n\n    # compute air molar mass\n    mm_inv = 1 / mm\n    weighted_mean_mm_inv = (mm_inv * y).sum(dim=\"m\") / y.sum(dim=\"m\")\n    mm_air = 1 / weighted_mean_mm_inv\n    mm_air.attrs.update({\"units\": \"g/mol\"})\n    return mm_air\n</code></pre>"},{"location":"reference/#joseki.profiles.util.number_density","title":"<code>joseki.profiles.util.number_density(p, t)</code>","text":"<p>Compute air number density from air pressure and air temperature.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Quantity</code> <p>Air pressure.</p> required <code>t</code> <code>Quantity</code> <p>Air temperature.</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>Number density.</p> Notes <p>The air number density is computed according to the ideal gas law:</p> \\[ n = \\frac{p}{k_B T} \\] <p>where \\(p\\) is the air pressure, \\(k_B\\) is the Boltzmann constant, and \\(T\\) is the air temperature.</p> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def number_density(p: pint.Quantity, t: pint.Quantity) -&gt; pint.Quantity:\n    \"\"\"Compute air number density from air pressure and air temperature.\n\n    Args:\n        p: Air pressure.\n        t: Air temperature.\n\n    Returns:\n        Number density.\n\n    Notes:\n        The air number density is computed according to the ideal gas law:\n\n        $$\n        n = \\\\frac{p}{k_B T}\n        $$\n\n        where $p$ is the air pressure, $k_B$ is the Boltzmann constant, and\n        $T$ is the air temperature.\n    \"\"\"\n    return (p / (K * t)).to_base_units()\n</code></pre>"},{"location":"reference/#joseki.profiles.util.utcnow","title":"<code>joseki.profiles.util.utcnow()</code>","text":"<p>Get current UTC time.</p> <p>Returns:</p> Type Description <code>str</code> <p>ISO 8601 formatted UTC timestamp.</p> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def utcnow() -&gt; str:\n    \"\"\"Get current UTC time.\n\n    Returns:\n        ISO 8601 formatted UTC timestamp.\n    \"\"\"\n    return datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n</code></pre>"},{"location":"reference/#joseki.core","title":"<code>joseki.core</code>","text":"<p>Core module.</p>"},{"location":"reference/#joseki.core.identifiers","title":"<code>joseki.core.identifiers()</code>","text":"<p>List all registered profile identifiers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of all registered profile identifiers.</p> Source code in <code>src/joseki/core.py</code> <pre><code>def identifiers() -&gt; t.List[str]:\n    \"\"\"\n    List all registered profile identifiers.\n\n    Returns:\n        List of all registered profile identifiers.\n    \"\"\"\n    return factory.registered_identifiers\n</code></pre>"},{"location":"reference/#joseki.core.load_dataset","title":"<code>joseki.core.load_dataset(path, *args, **kwargs)</code>","text":"<p>Thin wrapper around <code>xarray.load_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>Path to the dataset.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Profile.</p> Source code in <code>src/joseki/core.py</code> <pre><code>def load_dataset(path: os.PathLike, *args, **kwargs) -&gt; xr.Dataset:\n    \"\"\"\n    Thin wrapper around `xarray.load_dataset`.\n\n    Args:\n        path: Path to the dataset.\n\n    Returns:\n        Profile.\n    \"\"\"\n    return xr.load_dataset(path, *args, **kwargs)\n</code></pre>"},{"location":"reference/#joseki.core.make","title":"<code>joseki.core.make(identifier, z=None, interp_method=DEFAULT_METHOD, conserve_column=False, molecules=None, regularize=None, rescale_to=None, check_x_sum=False, **kwargs)</code>","text":"<p>Create a profile with the specified identifier.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Profile identifier.</p> required <code>z</code> <code>Quantity | dict | DataArray | None</code> <p>Altitude values.</p> <code>None</code> <code>interp_method</code> <code>Mapping[str, str] | None</code> <p>Mapping of variable and interpolation method.</p> <code>DEFAULT_METHOD</code> <code>conserve_column</code> <code>bool</code> <p>If <code>True</code>, ensure that column densities are conserved during interpolation.</p> <code>False</code> <code>molecules</code> <code>List[str] | None</code> <p>List of molecules to include in the profile.</p> <code>None</code> <code>regularize</code> <code>bool | dict | None</code> <p>Regularize the altitude grid with specified options which are passed to regularize.</p> <code>None</code> <code>rescale_to</code> <code>dict | None</code> <p>Rescale molecular concentrations to the specified target values which are passed to rescale_to.</p> <code>None</code> <code>check_x_sum</code> <code>bool</code> <p>If <code>True</code>, check that the mole fraction sums are less or equal to 1.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the profile constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Profile as xarray.Dataset.</p> See Also <p>regularize rescale_to</p> Source code in <code>src/joseki/core.py</code> <pre><code>def make(\n    identifier: str,\n    z: pint.Quantity | dict | xr.DataArray | None = None,\n    interp_method: t.Mapping[str, str] | None = DEFAULT_METHOD,\n    conserve_column: bool = False,\n    molecules: t.List[str] | None = None,\n    regularize: bool | dict | None = None,\n    rescale_to: dict | None = None,\n    check_x_sum: bool = False,\n    **kwargs: t.Any,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Create a profile with the specified identifier.\n\n    Args:\n        identifier: Profile identifier.\n        z: Altitude values.\n        interp_method: Mapping of variable and interpolation method.\n        conserve_column: If `True`, ensure that column densities are conserved\n            during interpolation.\n        molecules: List of molecules to include in the profile.\n        regularize: Regularize the altitude grid with specified options which\n            are passed to\n            [regularize](reference.md#src.joseki.profiles.core.regularize).\n        rescale_to: Rescale molecular concentrations to the specified target\n            values which are passed to\n            [rescale_to](reference.md#src.joseki.accessor.JosekiAccessor.rescale_to).\n        check_x_sum: If `True`, check that the mole fraction sums are less or\n            equal to 1.\n        kwargs: Additional keyword arguments passed to the profile constructor.\n\n    Returns:\n        Profile as xarray.Dataset.\n\n    See Also:\n        [regularize](reference.md#src.joseki.profiles.core.regularize)\n        [rescale_to](reference.md#src.joseki.accessor.JosekiAccessor.rescale_to)\n    \"\"\"\n    logger.info(\"Creating profile %s\", identifier)\n    logger.debug(\"z: %s\", z)\n    logger.debug(\"interp_method: %s\", interp_method)\n    logger.debug(\"conserve_column: %s\", conserve_column)\n    logger.debug(\"molecules: %s\", molecules)\n    logger.debug(\"regularize: %s\", regularize)\n    logger.debug(\"rescale_to: %s\", rescale_to)\n    logger.debug(\"kwargs: %s\", kwargs)\n\n    # Convert z to pint.Quantity\n    z = to_quantity(z) if z is not None else None\n\n    profile = factory.create(identifier)\n\n    logger.debug(\"exporting profile to xarray.Dataset\")\n    ds = profile.to_dataset(\n        z=z,\n        interp_method=interp_method,\n        conserve_column=conserve_column,\n        **kwargs,\n    )\n\n    # Molecules selection\n    if molecules is not None:\n        ds = select_molecules(ds, molecules)\n\n    # Altitude grid regularization\n    if regularize:\n        z = to_quantity(ds.z)\n        default_num = int((z.max() - z.min()) // np.diff(z).min()) + 1\n        if isinstance(regularize, bool):\n            regularize = {}\n        ds = _regularize(\n            ds=ds,\n            method=regularize.get(\"method\", DEFAULT_METHOD),\n            conserve_column=regularize.get(\"conserve_column\", False),\n            options=regularize.get(\"options\", {\"num\": default_num}),\n        )\n\n    # Molecular concentration rescaling\n    if rescale_to:\n        ds = ds.joseki.rescale_to(\n            target=rescale_to,\n            check_x_sum=check_x_sum,\n        )\n\n    return ds\n</code></pre>"},{"location":"reference/#joseki.core.merge","title":"<code>joseki.core.merge(datasets, new_title=None)</code>","text":"<p>Merge multiple profiles into a single profile.</p> <p>Parameters:</p> Name Type Description Default <code>datasets</code> <code>Iterable[Dataset]</code> <p>Iterable of profiles.</p> required <code>new_title</code> <code>str | None</code> <p>New title for the merged profile. If <code>None</code>, the title of the first profile is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Merged profile.</p> Notes <p>The first profile in the iterable is used as the base profile; when variables with the same name are encountered in subsequent profiles, the variable from the first profile is used.</p> Source code in <code>src/joseki/core.py</code> <pre><code>def merge(\n    datasets: t.Iterable[xr.Dataset],\n    new_title: str | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Merge multiple profiles into a single profile.\n\n    Args:\n        datasets: Iterable of profiles.\n        new_title: New title for the merged profile. If `None`, the title of\n            the first profile is used.\n\n    Returns:\n        Merged profile.\n\n    Notes:\n        The first profile in the iterable is used as the base profile; when\n        variables with the same name are encountered in subsequent profiles,\n        the variable from the first profile is used.\n    \"\"\"\n    merged = xr.merge(\n        datasets,\n        compat=\"override\",  # pick variable from first dataset\n        combine_attrs=\"override\",  # copy attrs from the first dataset to the result\n    )\n\n    # update attributes\n    now = datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n\n    institutions = set([ds.attrs[\"institution\"] for ds in datasets])\n    sources = set([ds.attrs[\"source\"] for ds in datasets])\n    references = set([ds.attrs[\"references\"] for ds in datasets])\n    urls = set([ds.attrs[\"url\"] for ds in datasets])\n    urldates = set([ds.attrs[\"urldate\"] for ds in datasets])\n    conventions = set([ds.attrs[\"Conventions\"] for ds in datasets])\n\n    with_profiles = \"with profile \" if len(datasets) == 2 else \"with profiles \"\n    with_profiles += \", \".join([f\"'{ds.title}'\" for ds in datasets[1:]])\n    merged.attrs[\"history\"] += (\n        f\"\\n{now} - merged profile '{datasets[0].title}' {with_profiles} \"\n        f\"joseki, version {__version__}\"\n    )\n\n    merged.attrs[\"institution\"] = \"\\n\".join(institutions)\n    merged.attrs[\"source\"] = \"\\n\".join(sources)\n    merged.attrs[\"references\"] = \"\\n\".join(references)\n    merged.attrs[\"url\"] = \"\\n\".join(urls)\n    merged.attrs[\"urldate\"] = \"\\n\".join(urldates)\n    merged.attrs[\"Conventions\"] = \"\\n\".join(conventions)\n\n    if new_title is not None:  # pragma: no cover\n        merged.attrs[\"title\"] = new_title\n    else:  # pragma: no cover\n        merged.attrs[\"title\"] = datasets[0].title\n\n    return merged\n</code></pre>"},{"location":"reference/#joseki.core.open_dataset","title":"<code>joseki.core.open_dataset(path, *args, **kwargs)</code>","text":"<p>Thin wrapper around <code>xarray.open_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>Path to the dataset.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Profile.</p> Source code in <code>src/joseki/core.py</code> <pre><code>def open_dataset(path: os.PathLike, *args, **kwargs) -&gt; xr.Dataset:\n    \"\"\"\n    Thin wrapper around `xarray.open_dataset`.\n\n    Args:\n        path: Path to the dataset.\n\n    Returns:\n        Profile.\n    \"\"\"\n    return xr.open_dataset(path, *args, **kwargs)\n</code></pre>"},{"location":"reference/#joseki.units","title":"<code>joseki.units</code>","text":"<p>Units module.</p>"},{"location":"reference/#joseki.units.to_quantity","title":"<code>joseki.units.to_quantity(value, units=None)</code>","text":"<p>Convert to a <code>pint.Quantity</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Quantity | dict | int | float | list | ndarray | DataArray</code> <p>Value which will be converted. If value is an <code>ArrayLike</code>, it is assumed to be dimensionless (unless <code>units</code> is set). If a <code>xarray.DataArray</code> is passed and <code>units_error</code> is <code>True</code>, it is assumed to have a <code>units</code> key in its <code>attrs</code> field; otherwise, it is assumed to be dimensionless.</p> required <code>units</code> <code>None | str</code> <p>Units to assign. If <code>None</code>, the units are inferred from the <code>value</code> argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Quantity</code> <p>The corresponding quantity.</p> Notes <p>This function can also be used on DataArray and Dataset coordinate variables.</p> Source code in <code>src/joseki/units.py</code> <pre><code>@singledispatch\ndef to_quantity(\n    value: pint.Quantity | dict | int | float | list | np.ndarray | xr.DataArray,\n    units: None | str = None,\n) -&gt; pint.Quantity:\n    \"\"\"Convert to a `pint.Quantity`.\n\n    Args:\n        value: Value which will be converted. If value is an `ArrayLike`, it is\n            assumed to be dimensionless (unless `units` is set).\n            If a `xarray.DataArray` is passed and\n            `units_error` is `True`, it is assumed to have a `units` key in\n            its `attrs` field; otherwise, it is assumed to be dimensionless.\n        units: Units to assign. If `None`, the units are inferred from the\n            `value` argument.\n\n    Returns:\n        The corresponding quantity.\n\n    Notes:\n        This function can also be used on DataArray and Dataset coordinate\n        variables.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#joseki.profiles.util","title":"<code>joseki.profiles.util</code>","text":"<p>Utility module.</p>"},{"location":"reference/#joseki.profiles.util.air_molar_mass_from_mass_fraction","title":"<code>joseki.profiles.util.air_molar_mass_from_mass_fraction(y)</code>","text":"<p>Compute the air molar mass from the of air constituents mass fractions.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>DataArray</code> <p>Mass fraction as a function of molecule (<code>m</code>) and altitude (<code>z</code>).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Air molar mass as a function of altitude (<code>z</code>).</p> Notes <p>The air molar mass is computed according to the following equation:</p> \\[ m_{\\mathrm{air}} (z) = \\left(     \\sum_{\\mathrm{M}} \\frac{         y_{\\mathrm{M}} (z)     }{         m_{\\mathrm{M}}     } \\right)^{-1} \\] <p>where:</p> <ul> <li>\\(y_{\\mathrm{M}} (z)\\) is the mass fraction of molecule M at altitude   \\(z\\),</li> <li>\\(m_{\\mathrm{M}}\\) is the molar mass of molecule M.</li> </ul> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def air_molar_mass_from_mass_fraction(y: xr.DataArray) -&gt; xr.DataArray:\n    r\"\"\"\n    Compute the air molar mass from the of air constituents mass fractions.\n\n    Args:\n        y: Mass fraction as a function of molecule (`m`) and altitude (`z`).\n\n    Returns:\n        Air molar mass as a function of altitude (`z`).\n\n    Notes:\n        The air molar mass is computed according to the following equation:\n\n        $$\n        m_{\\mathrm{air}} (z) = \\left(\n            \\sum_{\\mathrm{M}} \\frac{\n                y_{\\mathrm{M}} (z)\n            }{\n                m_{\\mathrm{M}}\n            }\n        \\right)^{-1}\n        $$\n\n        where:\n\n        * $y_{\\mathrm{M}} (z)$ is the mass fraction of molecule M at altitude\n          $z$,\n        * $m_{\\mathrm{M}}$ is the molar mass of molecule M.\n    \"\"\"\n    # compute molar masses along molecular species\n    molecules = y.m.values\n    mm = xr.DataArray(\n        data=[MM[m] for m in molecules],\n        coords={\"m\": (\"m\", molecules)},\n    )\n\n    # compute air molar mass\n    mm_inv = 1 / mm\n    weighted_mean_mm_inv = (mm_inv * y).sum(dim=\"m\") / y.sum(dim=\"m\")\n    mm_air = 1 / weighted_mean_mm_inv\n    mm_air.attrs.update({\"units\": \"g/mol\"})\n    return mm_air\n</code></pre>"},{"location":"reference/#joseki.profiles.util.number_density","title":"<code>joseki.profiles.util.number_density(p, t)</code>","text":"<p>Compute air number density from air pressure and air temperature.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Quantity</code> <p>Air pressure.</p> required <code>t</code> <code>Quantity</code> <p>Air temperature.</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>Number density.</p> Notes <p>The air number density is computed according to the ideal gas law:</p> \\[ n = \\frac{p}{k_B T} \\] <p>where \\(p\\) is the air pressure, \\(k_B\\) is the Boltzmann constant, and \\(T\\) is the air temperature.</p> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def number_density(p: pint.Quantity, t: pint.Quantity) -&gt; pint.Quantity:\n    \"\"\"Compute air number density from air pressure and air temperature.\n\n    Args:\n        p: Air pressure.\n        t: Air temperature.\n\n    Returns:\n        Number density.\n\n    Notes:\n        The air number density is computed according to the ideal gas law:\n\n        $$\n        n = \\\\frac{p}{k_B T}\n        $$\n\n        where $p$ is the air pressure, $k_B$ is the Boltzmann constant, and\n        $T$ is the air temperature.\n    \"\"\"\n    return (p / (K * t)).to_base_units()\n</code></pre>"},{"location":"reference/#joseki.profiles.util.utcnow","title":"<code>joseki.profiles.util.utcnow()</code>","text":"<p>Get current UTC time.</p> <p>Returns:</p> Type Description <code>str</code> <p>ISO 8601 formatted UTC timestamp.</p> Source code in <code>src/joseki/profiles/util.py</code> <pre><code>def utcnow() -&gt; str:\n    \"\"\"Get current UTC time.\n\n    Returns:\n        ISO 8601 formatted UTC timestamp.\n    \"\"\"\n    return datetime.datetime.utcnow().replace(microsecond=0).isoformat()\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Note</p> <p>There are no tutorials at the moment</p>"}]}